TrustStore, KeyStore and CertificateAuthority:
----------------------------------------------

	Real-World Analogy:
	-------------------
		CA = The government that issued the passport
		KeyStore = Your passport and signature
		TrustStore = A list of countries whose passports you trust
		
	Real-World Impact:
	------------------
		Without CAs:
		------------
			Without CAs, there would be no reliable way to verify the identity of websites or encrypt sensitive data. 
			You couldn’t safely shop online, do banking, or log into secure accounts.
			They help prevent man-in-the-middle attacks, phishing, and data breaches by ensuring that users connect to legitimate servers.

		With CAs:
		---------
			You get verified identities, encrypted communication, and browser trust, all essential for safe online experiences.	
		
			
		
	Below three are the backbone of "secure communication" in systems like Java, SSL/TLS, and microservices. 
	
	1. Keystore:
		Used by servers or clients to prove their identity during SSL/TLS handshakes.
		
	2. TrustStore:
		Used to validate the identity of the other party in a secure connection.
		
	
	1. Keystore: 
	------------	
		Stores private keys and their associated certificate chains. 
		
		Certificate Chain:
			Contains the public key (RSA) and identity information.
			
		Contains:
		---------
			Keystore Entry:
			- Alias: myserver
			- Private Key: RSA 2048-bit
			- Certificate: X.509 with RSA public key
				

	2. Truststore:
	--------------	
		Stores public certificates of trusted entities (usually Certificate Authorities). 
		Used to verify the identity of others.
		
		Contains:
		---------
			Truststore Entry:
			- Alias: rootCA
			- Certificate: X.509 with RSA public key

	
	3. Certificate Authority (CA):
	---------------------------
		A Certificate Authority is a trusted entity that:
			Issues: 	digital certificates,
			Verifies: 	the identity of websites, organizations or individuals,
			Signs: 		certificates to ensure authenticity And
			Enable: 	encrypted communication using Public Key Infrastructure (PKI)


		Enablement of HTTPS (encrypted communication):
		----------------------------------------------
			The certificate allows the website to use HTTPS, which encrypts data between the browser and server.
			This protects sensitive information like passwords, credit card numbers, and personal data from interception.


	Summary Table
	--------------
		Component				Stores What?				Used By				Role in SSL/TLS
		---------				------------				-------				---------------
		keystore				Private Key + Certificate	Server				Identity presentation
		Truststore				Trusted CA certificates		Client				Certificate verification
		Certificate Authority	Issues certificates			External entity		Establishes trust
	
	
	How They Work Together:
	-----------------------
		server: 	presents its certificate (from its KeyStore) during SSL/TLS handshake.	
		client:     Client uses truststore to verify the certificate using RSA public key.	(Verifying the cert)
		
		If the certificate is signed by a trusted CA, the connection proceeds securely.

	
	How It Works in SSL/TLS:
	------------------------
		Handshake begins: 				Client connects to server.
		Server sends certificate: 		Includes public key.
		Client verifies certificate: 	Using its truststore.
		Client encrypts a secret: 		With server’s public key.
		Server decrypts it: 			Using its private key.
		Secure session established: 	Using symmetric encryption from that point on.

			
	Note:
	-----
		Private key (used for signing or decrypting)
		Public certificate (used to prove identity)
		
		The private key is never shared—it stays securely on the device that owns it. If it’s leaked, the entire security of the system is compromised.
		

	Why the Client Encrypts a Secret with the Server’s Public Key:
	--------------------------------------------------------------
		When a client connects to a server over HTTPS (or any TLS-secured protocol), it needs to securely share a symmetric key that will be used for the actual data exchange. But how can it do that without anyone intercepting it?
		
		Here’s where public key cryptography comes in:
		----------------------------------------------
			Server sends its certificate to the client.
			This certificate contains the server’s public key.
			The client verifies the certificate using its truststore (which contains trusted CA certificates).
			Client generates a random secret (often called a pre-master secret).
			This will be used to derive the symmetric encryption key.
			Client encrypts the secret using the server’s public key.
			Only the server can decrypt it using its private key.
			Server decrypts the secret and both sides now derive the same symmetric key.
			Secure communication begins using fast symmetric encryption (e.g., AES).


	Why This Matters:
	-----------------
		Confidentiality: Even if someone intercepts the encrypted secret, they can’t decrypt it without the server’s private key.
		Authentication: The client knows it’s talking to the real server (assuming the certificate is valid).
		Performance: 	After the handshake, symmetric encryption is used for speed.
		
		
	Who Uses the Private Key?
	-------------------------
		Server (most common):
		---------------------
			The server uses its private key to:
			Decrypt data sent by the client that was encrypted with the server’s public key.
			Sign data to prove its identity during the TLS handshake.
			This ensures that the client is talking to the real server and not an imposter.
		
		Client (in mutual TLS):
		-----------------------
			If mutual TLS is enabled, the client also has a certificate and private key.
			The client uses its private key to:
			Authenticate itself to the server.
			Sign messages or decrypt data during handshake.
	



Here’s how you can "generate or import" certificates using the "keytool" utility in Java:
-----------------------------------------------------------------------------------------

	Generate a KeyPair and Certificate with keytool:
	------------------------------------------------
		If you're creating a new self-signed certificate and storing it in a KeyStore:
		
			keytool -genkeypair -alias mykey -keyalg RSA -keystore keystore.jks -keysize 2048 -validity 365

			-alias: 	Name for the key
			-keyalg: 	Algorithm (e.g. RSA)
			-keystore: 	Output KeyStore file
			-validity: 	Number of days the certificate is valid
		
			You’ll be prompted for:
				Password for the KeyStore
				Distinguished Name (e.g., CN, OU, O, L, ST, C)


	Import a Certificate into a TrustStore:
	---------------------------------------
		If you have a certificate file (server.crt) and want to trust it:
		
			keytool -importcert -alias servercert -file server.crt -keystore truststore.jks

			This stores the trusted certificate in a TrustStore
			You’ll be prompted to confirm it’s trusted

	
	View Contents of a KeyStore or TrustStore:
	------------------------------------------
		keytool -list -v -keystore keystore.jks

		Useful to confirm entries and aliases inside
