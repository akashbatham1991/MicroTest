https://medium.com/@AlexanderObregon/connecting-spring-boot-applications-to-mysql-databases-ea025e4b5f19
https://docs.spring.io/spring-framework/reference/data-access/jdbc/connections.html


Spring Boot allows you to define the database configuration in a properties file. 
This file is usually named application.properties and is located in the src/main/resources folder.

Connecting a Spring Boot application to a MySQL database involves:  
------------------------------------------------------------------
	1. setting up the required dependencies in pom.xml file, 
	2. configuring the connection in application.properties file and 
	3. creating the necessary components(entities and repositories) to manage data persistence. 

	
	
	1)
	the following dependencies need to be added to the pom.xml file:
			<dependencies>
			
				<!-- Provides support for JPA and Hibernate for database interactions -->
				
					<dependency>
						<groupId>org.springframework.boot</groupId>
						<artifactId>spring-boot-starter-data-jpa</artifactId>
					</dependency>

				<!-- Provides tools to create RESTful APIs -->
				
					<dependency>
						<groupId>org.springframework.boot</groupId>
						<artifactId>spring-boot-starter-web</artifactId>
					</dependency>

				<!-- Enables MySQL database connection -->
				
					<dependency>
						<groupId>mysql</groupId>
						<artifactId>mysql-connector-java</artifactId>
						<scope>runtime</scope>
					</dependency>

				<!-- Adds validation support for entity classes -->
				
					<dependency>
						<groupId>org.springframework.boot</groupId>
						<artifactId>spring-boot-starter-validation</artifactId>
					</dependency>
			</dependencies>
		
		
	2)
	Configure application.properties:
	---------------------------------
		spring.datasource.url=jdbc:mysql://localhost:3306/mydatabase
		spring.datasource.username=root
		spring.datasource.password=123456
		spring.datasource.driver-class-name=com.mysql.jdbc.Driver
		spring.jpa.hibernate.ddl-auto=update	
		spring.jpa.show-sql=true
		
		
	If using application.yml, the same settings are structured differently:
	----------------------------------------------------------------------
			spring:
			  datasource:
				url: jdbc:mysql://localhost:3306/your_database_name
				username: your_username
				password: your_password
				driver-class-name: com.mysql.cj.jdbc.Driver
			  jpa:
				hibernate:
				  ddl-auto: update
				show-sql: true

		
		spring.jpa.hibernate.ddl-auto:
		------------------------------
		1. none: No action is taken.
		2. update: Updates the schema to match the entity classes. Use with caution in production, as it may alter existing tables and data.
		3. create: Creates the schema every time the application starts (drops existing data).
		4. create-drop: Creates the schema at startup and drops it on shutdown.
		
		Note: 
			It’s recommended to avoid ‘update’, ‘create’, or ‘create-drop’ in production environments. 
			Instead, use database migration tools like Flyway or Liquibase for managing schema changes safely.
		
		
	3)Create the Database in MySQL:
	-------------------------------
		Before the Spring Boot application can interact with the database, the specified database must exist. 
		create the database. 
		
		For example, using the command line:
			
			CREATE DATABASE your_database_name;
		
	
Conclusion:
-----------
	Connecting a Spring Boot application to a MySQL database involves configuring dependencies, defining the connection properties, and setting up entity classes and repositories. With these steps in place, you can perform CRUD operations efficiently and apply best practices to maintain application performance and data integrity.	
	
	
======================================================================================================================================

https://github.com/bouguern/spring-boot-multi-DB-config
https://medium.com/@bouguern.mohamed/configure-multiple-data-sources-postgres-mysql-in-a-spring-boot-3-03f67e45c287
https://riteshshergill.medium.com/multi-database-connections-with-spring-boot-80d66f97d39f

Configure Multiple Data Sources -Postgres & MySQL in a Spring Boot:
-------------------------------------------------------------------

Steps to configure multiple databases in a Spring Boot application, including:
------------------------------------------------------------------------------
	— Defining Entities
	— Creating Repositories
	— Configuring Datasources
	— Setting up the application.properties

Let’s create two entities (User and Product), with each living in a separate database.
We created these two repositories: UserRepository and ProductRepository.

We’ll first set up two configuration classes — one for the User and the other for the Product. 

In each configuration class, will define the Spring bean for: 
	Data Source, 
	Entity Manager Factory, and 
	Transaction Manager.
	
	The UserDBConfig:
	-----------------
		package bouguern.tuto.demo.DBConfig;

		import java.util.HashMap;

		import javax.sql.DataSource;

		import org.springframework.beans.factory.annotation.Qualifier;
		import org.springframework.boot.context.properties.ConfigurationProperties;
		import org.springframework.boot.jdbc.DataSourceBuilder;
		import org.springframework.boot.orm.jpa.EntityManagerFactoryBuilder;
		import org.springframework.context.annotation.Bean;
		import org.springframework.context.annotation.Configuration;
		import org.springframework.context.annotation.Primary;
		import org.springframework.data.jpa.repository.config.EnableJpaRepositories;
		import org.springframework.orm.jpa.JpaTransactionManager;
		import org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;
		import org.springframework.transaction.PlatformTransactionManager;
		import org.springframework.transaction.annotation.EnableTransactionManagement;

		import jakarta.persistence.EntityManagerFactory;


		@Configuration
		@EnableJpaRepositories(
		  entityManagerFactoryRef = "db1EntityManagerFactory", 
		  transactionManagerRef = "db1TransactionManager",
		  basePackages = { "bouguern.tuto.demo.user" })
		@EnableTransactionManagement
		public class UserDBConfig {
		 
		 @Primary
		 @Bean(name = "dataSource1")
		 @ConfigurationProperties(prefix = "spring.db1.datasource")
		 DataSource dataSource() {
		  return DataSourceBuilder.create().build();
		 }

		 @Primary
		 @Bean(name = "db1EntityManagerFactory")
		 LocalContainerEntityManagerFactoryBean db1EntityManagerFactory(final EntityManagerFactoryBuilder builder,
		   @Qualifier("dataSource1") DataSource dataSource) {
		  
		  final HashMap<String, String> properties = new HashMap<>();
		  properties.put("hibernate.hbm2ddl.auto", "update");
		  //properties.put("hibernate.dialect", "org.hibernate.dialect.MariaDBDialect");

		  return builder.dataSource(dataSource)
			   .properties(properties)
			   .packages("bouguern.tuto.demo.user")
			   .persistenceUnit("user")
			   .build();
		 }

		 @Primary
		 @Bean(name = "db1TransactionManager")
		 PlatformTransactionManager db1TransactionManager(@Qualifier("db1EntityManagerFactory") final EntityManagerFactory entityManagerFactory) {
		  return new JpaTransactionManager(entityManagerFactory);
		 }
		}


	The ProductDBConfig:
	--------------------
		package bouguern.tuto.demo.DBConfig;

		import java.util.HashMap;

		import javax.sql.DataSource;

		import org.springframework.beans.factory.annotation.Qualifier;
		import org.springframework.boot.context.properties.ConfigurationProperties;
		import org.springframework.boot.jdbc.DataSourceBuilder;
		import org.springframework.boot.orm.jpa.EntityManagerFactoryBuilder;
		import org.springframework.context.annotation.Bean;
		import org.springframework.context.annotation.Configuration;
		import org.springframework.data.jpa.repository.config.EnableJpaRepositories;
		import org.springframework.orm.jpa.JpaTransactionManager;
		import org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;
		import org.springframework.transaction.PlatformTransactionManager;
		import org.springframework.transaction.annotation.EnableTransactionManagement;

		import jakarta.persistence.EntityManagerFactory;

		@Configuration
		@EnableJpaRepositories(entityManagerFactoryRef = "db2EntityManagerFactory", transactionManagerRef = "db2TransactionManager", basePackages = {
		  "bouguern.tuto.demo.product" })
		@EnableTransactionManagement
		public class ProductDBConfig {

		 @Bean(name = "db2DataSource")
		 @ConfigurationProperties(prefix = "spring.db2.datasource")
		 DataSource dataSource() {
		  return DataSourceBuilder.create().build();
		 }

		 @Bean(name = "db2EntityManagerFactory")
		 LocalContainerEntityManagerFactoryBean db2EntityManagerFactory(final EntityManagerFactoryBuilder builder,
		   @Qualifier("db2DataSource") final DataSource dataSource) {

		  final HashMap<String, String> properties = new HashMap<>();
		  properties.put("hibernate.hbm2ddl.auto", "update");
		  return builder.dataSource(dataSource).properties(properties).packages("bouguern.tuto.demo.product")
			.persistenceUnit("product").build();
		 }

		 @Bean(name = "db2TransactionManager")
		 PlatformTransactionManager db2TransactionManager(
		   @Qualifier("db2EntityManagerFactory") final EntityManagerFactory entityManagerFactory) {
		  return new JpaTransactionManager(entityManagerFactory);
		 }
		}

Note:
-----	
	The dataSource() method which is annotated with the @ConfigurationProperties annotation. The annotation has a prefix property which tells the spring that the properties for this data source are prefixed with the given value and should be used for creating the data source instance. The properties are read from the application.properties file. Inside this method, we’re using a DataSourceBuilder, and Spring Boot will automatically take care of the rest.

	The db1EntityManagerFactory() method is responsible for creating the LocalContainerEntityManagerFactoryBean instance for the data source.

	The db1TransactionManager() method is responsible for creating the PlatformTransactionManager instance for this data source to handle the transaction management.	
	
	Also, the use of @Primary annotation in this class tells Spring to treat the bean instances defined in this class as the primary beans.
	
	Notice how we use the userTransactionManager as our Primary TransactionManager by annotating the bean definition with @Primary. That’s helpful whenever we’re going to implicitly or explicitly inject the transaction manager without specifying which one by name.
	
	
Here we will define the two data sources for Postgres and Mysql databases along with database and 
application properties:
-----------------------
	spring.application.name=spring-boot-multi-DB-config
	server.port=9095

	## MySQL
	spring.db1.datasource.jdbc-url=jdbc:mysql://localhost:3306/userDB?createDatabaseIfNotExist=true
	spring.db1.datasource.username=root
	spring.db1.datasource.password=root
	spring.db1.datasource.driver-class-name=com.mysql.cj.jdbc.Driver


	## PostgresSQL
	## Postgres does not support createDatabaseIfNotExist=true, 
	## so you need to create the 'productDB' database in Postgres before running the app.
	spring.db2.datasource.jdbc-url=jdbc:postgresql://localhost:5432/productDB
	spring.db2.datasource.username=postgres
	spring.db2.datasource.password=postgres
	spring.db2.datasource.driver-class-name=org.postgresql.Driver

	spring.jpa.show-sql=true
	spring.jpa.hibernate.ddl-auto=update
			
	
	Pro Tip:
		Consider using profiles if you want to switch between environments.	
	
	
	
	
	
	
======================================================================================================================================
	
-----------------------------------	
Best Practices and Common Problems:
-----------------------------------
	1. Use Connection Pooling
	2. Avoid Hardcoding Sensitive Information
	3. Validate Inputs
	4. Log SQL Queries in Development
	5. Index Frequently Queried Columns
	6. Connection Issues Problem
	7. LazyInitializationException Problem
	8. Duplicate Data Problem
	9. Query Performance Issues Problem
	10. Schema Updates in Production Problem
	11. Handling Exceptions Problem
	
	
	1.Use Connection Pooling:
	-------------------------
		Spring Boot uses HikariCP as the default connection pool. 
		Connection pooling improves performance by reusing database connections instead of creating a new one for every request. 
		Verify the default setup or customize it in the application.properties file:
		
			spring.datasource.hikari.maximum-pool-size=10
			spring.datasource.hikari.minimum-idle=2
			spring.datasource.hikari.idle-timeout=30000  # in milliseconds
			spring.datasource.hikari.max-lifetime=1800000  # in milliseconds
		
		These settings control the maximum number of connections, idle connection behavior, and lifetime.
	
		
	2.Avoid Hardcoding Sensitive Information:
	-----------------------------------------
		Storing database credentials directly in the application.properties file is convenient but can lead to security issues. 
		Use environment variables or tools like Spring Boot’s @ConfigurationProperties to externalize sensitive data. 
		For example, use:

			spring.datasource.username=${DB_USERNAME}
			spring.datasource.password=${DB_PASSWORD}
		
		Set DB_USERNAME and DB_PASSWORD as environment variables to keep credentials out of source control.	
		
		
		
	3.Validate Inputs:
	------------------	
		Always validate data before saving it to the database. Use validation annotations in your entity classes, such as:

			@NotNull
			@Size(min = 3, max = 50)
			private String name;

			@Min(0)
			private Double salary;
		
		This makes sure that the data meets your application’s requirements before interacting with the database.	
		
		
	4. Log SQL Queries in Development:
	----------------------------------	
		During development, enable SQL logging to analyze queries executed by Hibernate. However, turn this off in production for better performance:

			spring.jpa.show-sql=true
			spring.jpa.properties.hibernate.format_sql=true
	
		This setting helps you identify inefficient queries during development.	
		
		
	5. Index Frequently Queried Columns:
	------------------------------------	
		Optimize database performance by adding indexes to columns often used in WHERE clauses or joins. For example, create an index on the department column if it’s frequently queried:
			
			CREATE INDEX idx_department ON employee(department);
		
		Indexes speed up lookups but increase write operation overhead, so use them judiciously.	
		
		
	6. Connection Issues Problem:
	-----------------------------
		The application fails to connect to the database, often due to incorrect credentials, database URL, or driver configuration.

		Solution:
		---------
			Double-check spring.datasource.url, spring.datasource.username, and spring.datasource.password in the configuration file.
			Confirm the MySQL service is running and accessible on the specified host and port.
			
			Use the MySQL command-line client to test the credentials and connection manually:
				
				mysql -u your_username -p -h localhost -P 3306	
				

	7. LazyInitializationException Problem:
	---------------------------------------
		This exception occurs when trying to access a lazily loaded entity outside a transactional context.

		Solution:
		---------
			Use @Transactional on service layer methods that involve fetching and modifying lazy-loaded associations to ensure they operate within a transactional context.
			Fetch required associations eagerly if they’re always needed. For example
			
			@OneToMany(fetch = FetchType.EAGER)
			private List<Project> projects;		
			
			
	8. Duplicate Data Problem:
	--------------------------
		Duplicate records are inserted into the database due to unintended multiple calls to save().

		Solution:
		---------
			Use unique constraints in your database schema:
				
				ALTER TABLE employee ADD CONSTRAINT unique_name UNIQUE(name);
			
			Validate data in the service layer before saving to prevent duplicates programmatically.		
			
			
	9. Query Performance Issues Problem:
	------------------------------------
		Slow query performance when fetching large datasets or running complex joins.

		Solution:
		---------
			1. Optimize queries using native SQL or JPQL for specific use cases.
			
			2. Use pagination for large datasets instead of fetching all records at once:
				
				@GetMapping
				public Page<Employee> getEmployees(Pageable pageable) {
					return repository.findAll(pageable);
				}		
				
				
	10. Schema Updates in Production Problem:
	-----------------------------------------
		Using spring.jpa.hibernate.ddl-auto=update can unintentionally alter the database schema in production, potentially causing data loss.

		Solution:
		---------
			Avoid update or create in production environments. Use a tool like Flyway or Liquibase for schema migrations.

			Configure Flyway in pom.xml:
				<dependency>
					<groupId>org.flywaydb</groupId>
					<artifactId>flyway-core</artifactId>
				</dependency>
			
			Create migration scripts to handle schema changes safely and predictably.			
			
			
	11. Handling Exceptions Problem:
	--------------------------------
		Errors such as DataIntegrityViolationException or ConstraintViolationException may occur when violating database constraints.

		Solution:
		---------
			Use @ExceptionHandler in controllers to provide meaningful error responses:

				@RestControllerAdvice
				public class GlobalExceptionHandler {
					@ExceptionHandler(DataIntegrityViolationException.class)
					public ResponseEntity<String> handleDataIntegrityViolation(DataIntegrityViolationException ex) {
						return ResponseEntity.badRequest().body("Invalid data: " + ex.getMessage());
					}
				}		
				
				
	Conclusion:
	-----------
		By addressing common issues proactively, you can build reliable and scalable applications that effectively manage data persistence. 