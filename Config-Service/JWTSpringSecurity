https://www.youtube.com/watch?v=q2l91Ffc_8U
https://www.youtube.com/watch?v=jQrExUrNbQE

interviewQ: https://www.interviewbit.com/spring-security-interview-questions/

https://www.toptal.com/spring/spring-security-tutorial
https://www.baeldung.com/security-spring
https://spring.io/guides/topicals/spring-security-architecture

https://www.toptal.com/spring/spring-security-tutorial

	Authentication Using JWT with Spring Security
	JWT Authorization with Spring Security
	Testing Our Spring Security JWT Solution


->Spring Security is a powerful and customizable authentication and authorization framework. 


Defining Terminology:
---------------------
	Authentication: refers to the process of verifying the identity of a user, based on provided credentials. 
	Authorization: 	refers to the process of determining if a user has proper permission to perform a particular action.
	Principle: 		refers to the currently authenticated user.
	Granted: 		authority refers to the permission of the authenticated user.
	Role: 			refers to a group of permissions of the authenticated user.
	

Authentication Using JWT with Spring Security:
----------------------------------------------
	
	1)
		we need a configuration class annotated with @EnableWebSecurity annotation in our classpath. 
		
			@EnableWebSecurity
			public class SecurityConfig extends WebSecurityConfigurerAdapter {

				@Override
				protected void configure(AuthenticationManagerBuilder auth) throws Exception {
					// TODO configure authentication manager
				}

				@Override
				protected void configure(HttpSecurity http) throws Exception {
					// TODO configure web security
				}

			}
			
	2)		
	Now, when we accept the authentication request, we need to retrieve the correct identity from the database using the provided credentials and then verify it. For this, we need the implementation of the UserDetailsService interface, which is defined as follows:

		public interface UserDetailsService {
			UserDetails loadUserByUsername(String username) throws UsernameNotFoundException;

		}		
		
		Note:
			In our sample application, we store user identities in a MongoDB database, in the users collection. These identities are mapped by the User entity, and their CRUD operations are defined by the UserRepo Spring Data repository.
			
		Considering the fact that it exposes only the single-function prototype, we can treat it as a functional interface and provide implementation as a lambda expression:
			
			@EnableWebSecurity
			public class SecurityConfig extends WebSecurityConfigurerAdapter {

				private final UserRepo userRepo;

				public SecurityConfig(UserRepo userRepo) {
					this.userRepo = userRepo;
				}

				@Override
				protected void configure(AuthenticationManagerBuilder auth) throws Exception {
					auth.userDetailsService(username -> userRepo
						.findByUsername(username)
						.orElseThrow(
							() -> new UsernameNotFoundException(
								format("User: %s, not found", username)
							)
						));
				}

				@Bean
				public PasswordEncoder passwordEncoder() {
					return new BCryptPasswordEncoder();
				}

				// Details omitted for brevity

			}

			//Here, the auth.userDetailsService function call will initiate the DaoAuthenticationProvider instance using our implementation of the UserDetailsService interface and register it in the authentication manager.
			
			Along with the authentication provider, we need to configure an authentication manager with the correct password-encoding schema that will be used for credentials verification. For this, we need to expose the preferred implementation of the PasswordEncoder interface as a bean as above.
			
	3)
	Having configured the authentication manager, we now need to configure web security. We are implementing a REST API and need stateless authentication with a JWT token; therefore, we need to set the following options:
		Enable CORS and disable CSRF.
		Set session management to stateless.
		Set unauthorized requests exception handler.
		Set permissions on endpoints.
		Add JWT token filter.	
		
	This configuration is implemented as follows:
	---------------------------------------------
		@EnableWebSecurity
		public class SecurityConfig extends WebSecurityConfigurerAdapter {

			private final UserRepo userRepo;
			private final JwtTokenFilter jwtTokenFilter;

			public SecurityConfig(UserRepo userRepo,
								  JwtTokenFilter jwtTokenFilter) {
				this.userRepo = userRepo;
				this.jwtTokenFilter = jwtTokenFilter;
			}

			// Details omitted for brevity

			@Override
			protected void configure(HttpSecurity http) throws Exception {
				// Enable CORS and disable CSRF
				http = http.cors().and().csrf().disable();

				// Set session management to stateless
				http = http
					.sessionManagement()
					.sessionCreationPolicy(SessionCreationPolicy.STATELESS)
					.and();

				// Set unauthorized requests exception handler
				http = http
					.exceptionHandling()
					.authenticationEntryPoint(
						(request, response, ex) -> {
							response.sendError(
								HttpServletResponse.SC_UNAUTHORIZED,
								ex.getMessage()
							);
						}
					)
					.and();

				// Set permissions on endpoints
				http.authorizeRequests()
					// Our public endpoints
					.antMatchers("/api/public/**").permitAll()
					.antMatchers(HttpMethod.GET, "/api/author/**").permitAll()
					.antMatchers(HttpMethod.POST, "/api/author/search").permitAll()
					.antMatchers(HttpMethod.GET, "/api/book/**").permitAll()
					.antMatchers(HttpMethod.POST, "/api/book/search").permitAll()
					// Our private endpoints
					.anyRequest().authenticated();

				// Add JWT token filter
				http.addFilterBefore(
					jwtTokenFilter,
					UsernamePasswordAuthenticationFilter.class
				);
			}

			// Used by Spring Security if CORS is enabled.
			@Bean
			public CorsFilter corsFilter() {
				UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
				CorsConfiguration config = new CorsConfiguration();
				config.setAllowCredentials(true);
				config.addAllowedOrigin("*");
				config.addAllowedHeader("*");
				config.addAllowedMethod("*");
				source.registerCorsConfiguration("/**", config);
				return new CorsFilter(source);
			}
		}
		
		Please note that we added the JwtTokenFilter before the Spring Security internal UsernamePasswordAuthenticationFilter. We’re doing this because we need access to the user identity at this point to perform authentication/authorization, and its extraction happens inside the JWT token filter based on the provided JWT token. This is implemented as follows:

			@Component
			public class JwtTokenFilter extends OncePerRequestFilter {

				private final JwtTokenUtil jwtTokenUtil;
				private final UserRepo userRepo;

				public JwtTokenFilter(JwtTokenUtil jwtTokenUtil,
									  UserRepo userRepo) {
					this.jwtTokenUtil = jwtTokenUtil;
					this.userRepo = userRepo;
				}

				@Override
				protected void doFilterInternal(HttpServletRequest request,
												HttpServletResponse response,
												FilterChain chain)
						throws ServletException, IOException {
				// Get authorization header and validate
					final String header = request.getHeader(HttpHeaders.AUTHORIZATION);
					if (isEmpty(header) || !header.startsWith("Bearer ")) {
						chain.doFilter(request, response);
						return;
					}

				// Get jwt token and validate
					final String token = header.split(" ")[1].trim();
					if (!jwtTokenUtil.validate(token)) {
						chain.doFilter(request, response);
						return;
					}

				// Get user identity and set it on the spring security context
					UserDetails userDetails = userRepo
						.findByUsername(jwtTokenUtil.getUsername(token))
						.orElse(null);

					UsernamePasswordAuthenticationToken
						authentication = new UsernamePasswordAuthenticationToken(
							userDetails, null,
							userDetails == null ?
								List.of() : userDetails.getAuthorities()
						);

					authentication.setDetails(
						new WebAuthenticationDetailsSource().buildDetails(request)
					);

					SecurityContextHolder.getContext().setAuthentication(authentication);
					chain.doFilter(request, response);
				}
			}
			
			
	4)
	And now, we are ready to implement our login API function:	
		@Api(tags = "Authentication")
		@RestController @RequestMapping(path = "api/public")
		public class AuthApi {

			private final AuthenticationManager authenticationManager;
			private final JwtTokenUtil jwtTokenUtil;
			private final UserViewMapper userViewMapper;

			public AuthApi(AuthenticationManager authenticationManager,
						   JwtTokenUtil jwtTokenUtil,
						   UserViewMapper userViewMapper) {
				this.authenticationManager = authenticationManager;
				this.jwtTokenUtil = jwtTokenUtil;
				this.userViewMapper = userViewMapper;
			}

			@PostMapping("login")
			public ResponseEntity<UserView> login(@RequestBody @Valid AuthRequest request) {
				try {
					Authentication authenticate = authenticationManager
						.authenticate(
							new UsernamePasswordAuthenticationToken(
								request.getUsername(), request.getPassword()
							)
						);

					User user = (User) authenticate.getPrincipal();

					return ResponseEntity.ok()
						.header(
							HttpHeaders.AUTHORIZATION,
							jwtTokenUtil.generateAccessToken(user)
						)
						.body(userViewMapper.toUserView(user));
				} catch (BadCredentialsException ex) {
					return ResponseEntity.status(HttpStatus.UNAUTHORIZED).build();
				}
			}

		}
		
		//Here, we verify the provided credentials using the authentication manager, and in case of success, we generate the JWT token and return it as a response header along with the user identity information in the response body.
		
		
JWT Authorization with Spring Security:
=======================================
	In the previous section, we set up a Spring JWT authentication process and configured public/private URLs. This may be enough for simple applications, but for most real-world use cases, we always need role-based access policies for our users. In this chapter, we will address this issue and set up a role-based authorization schema using the Spring Security framework.

	In our sample application, we have defined the following three roles:
		USER_ADMIN allows us to manage application users.
		AUTHOR_ADMIN allows us to manage authors.
		BOOK_ADMIN allows us to manage books.

	Now, we need to apply them to the corresponding URLs:
		api/public is publicly accessible.
		api/admin/user can access users with the USER_ADMIN role.
		api/author can access users with the AUTHOR_ADMIN role.
		api/book can access users with the BOOK_ADMIN role.	
		
	The Spring Security framework provides us with two options to set up the authorization schema:
		1) URL-based configuration
		2) Annotation-based configuration	
		
		1)
		First, let’s see how URL-based configuration works. It can be applied to the web security configuration as follows:
		
			@EnableWebSecurity
			public class SecurityConfig extends WebSecurityConfigurerAdapter {

				// Details omitted for brevity

				@Override
				protected void configure(HttpSecurity http) throws Exception {
					// Enable CORS and disable CSRF
					http = http.cors().and().csrf().disable();

					// Set session management to stateless
					http = http
						.sessionManagement()
						.sessionCreationPolicy(SessionCreationPolicy.STATELESS)
						.and();

					// Set unauthorized requests exception handler
					http = http
						.exceptionHandling()
						.authenticationEntryPoint(
							(request, response, ex) -> {
								response.sendError(
									HttpServletResponse.SC_UNAUTHORIZED,
									ex.getMessage()
								);
							}
						)
						.and();

					// Set permissions on endpoints
					http.authorizeRequests()
						// Our public endpoints
						.antMatchers("/api/public/**").permitAll()
						.antMatchers(HttpMethod.GET, "/api/author/**").permitAll()
						.antMatchers(HttpMethod.POST, "/api/author/search").permitAll()
						.antMatchers(HttpMethod.GET, "/api/book/**").permitAll()
						.antMatchers(HttpMethod.POST, "/api/book/search").permitAll()
						// Our private endpoints
						.antMatchers("/api/admin/user/**").hasRole(Role.USER_ADMIN)
						.antMatchers("/api/author/**").hasRole(Role.AUTHOR_ADMIN)
						.antMatchers("/api/book/**").hasRole(Role.BOOK_ADMIN)
						.anyRequest().authenticated();

					// Add JWT token filter
					http.addFilterBefore(
						jwtTokenFilter,
						UsernamePasswordAuthenticationFilter.class
					);
				}

				// Details omitted for brevity
			}
			
			
			As you can see, this approach is simple and straightforward, but it has one downside. The authorization schema in our application can be complex, and if we define all the rules in a single place, it will become very big, complex, and hard to read. Because of this, I usually prefer to use annotation-based configuration.

		2)
		The Spring Security framework defines the following annotations for web security:
		---------------------------------------------------------------------------------
			@PreAuthorize:	provide expression-based access control before executing the method.
			@PostAuthorize:	provide expression-based access control after executing the method.
			@PreFilter:		used to filter the collection or arrays before executing the method.
			@PostFilter:	used to filter the returned collection or arrays after executing the method.
			@Secured:		used to specify a list of roles on a method.
			@RolesAllowed:	is the JSR 250’s equivalent annotation of the @Secured annotation.
			
			These annotations are disabled by default and can be enabled in our application as follows:
			
				@EnableWebSecurity
				@EnableGlobalMethodSecurity(
					securedEnabled = true,
					jsr250Enabled = true,
					prePostEnabled = true
				)
				public class SecurityConfig extends WebSecurityConfigurerAdapter {

					// Details omitted for brevity
				}
				
			Note:
				securedEnabled = true enables @Secured annotation.
				jsr250Enabled = true enables @RolesAllowed annotation.
				prePostEnabled = true enables @PreAuthorize, @PostAuthorize, @PreFilter, @PostFilter annotations.

			
		After enabling them, we can enforce role-based access policies on our API endpoints like this:
			A)
					@Api(tags = "UserAdmin")
					@RestController @RequestMapping(path = "api/admin/user")
					@RolesAllowed(Role.USER_ADMIN)
					public class UserAdminApi {

						// Details omitted for brevity

					}
		
			B)
					@Api(tags = "Author")
					@RestController @RequestMapping(path = "api/author")
					public class AuthorApi {

						// Details omitted for brevity

						@RolesAllowed(Role.AUTHOR_ADMIN)
						@PostMapping
						public void create() { }

						@RolesAllowed(Role.AUTHOR_ADMIN)
						@PutMapping("{id}")
						public void edit() { }

						@RolesAllowed(Role.AUTHOR_ADMIN)
						@DeleteMapping("{id}")
						public void delete() { }

						@GetMapping("{id}")
						public void get() { }

						@GetMapping("{id}/book")
						public void getBooks() { }

						@PostMapping("search")
						public void search() { }

					}
					
			Note:
				Please note that security annotations can be provided both on the class level and the method level.

			The Spring Security framework differentiates two terms:
				Authority:	 represents an individual permission.
				Role:		 represents a group of permissions.

				Authority: 	@PreAuthorize(“hasAuthority(‘EDIT_BOOK’)”)
				Role: 		@PreAuthorize(“hasRole(‘BOOK_ADMIN’)”)

				To make the difference between these two terms more explicit, the Spring Security framework adds a ROLE_ prefix to the role name by default. So, instead of checking for a role named BOOK_ADMIN, it will check for ROLE_BOOK_ADMIN.
				
				
				Personally, I find this behavior confusing and prefer to disable it in my applications. It can be disabled inside the Spring Security configuration as follows:
					@EnableWebSecurity
					public class SecurityConfig extends WebSecurityConfigurerAdapter {

						// Details omitted for brevity

						@Bean
						GrantedAuthorityDefaults grantedAuthorityDefaults() {
							return new GrantedAuthorityDefaults(""); // Remove the ROLE_ prefix
						}
					}
