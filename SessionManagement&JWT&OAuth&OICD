Cookies : Session cookie, persistent Cookie.

(Browser cookie, localStorage, sessionStorage) : HttpOnly, Secure, SameSite

XSS (Cross-Site Scripting): HttpOnly 				
CSRF (Cross-Site Request Forgery): SameSite

Auth0, Firebase, AWS Cognito, and Azure AD

OAuth 2.0, OpenID Connect

JWT, Opaque Token

Authorization Code, Access Token, ID Token, Session token

SessionID, Session, JSESSIONID, Session Data

Session Management, Types, Implementations

HttpSession uses JSESSIONID while SpringSession uses SessionIdGenerator to generate sessionId?


Resource Server, Authorization Server, Client App

Login Flow.
------------------------------


Cookies are small 'text files' stored by the browser on the user's device. 
Each cookie is a key-value pair with optional metadata like: expiration, path, domain, and security flags.
Cookies are stored in the browser's "internal cookie store".

Types of cookies:
	Session Cookie 		Expires when the browser is closed
	Persistent Cookie 	Remains until a specified expiration date/time
	
	Use cookies for: 			server-related data (e.g., login tokens).
	Use localStorage for: 		persistent client-side data. (e.g., preferences or form progress)
	Use sessionStorage for: 	temporary, tab-specific data	
	
	
Manually setting session IDs can lead to security risks and session mismatches.
Always let the server generate and manage session IDs (JSESSIONID).

JSESSIONID:
-----------
	JSESSIONID is the key.
	Session data is the value stored securely on the server.
	The server uses the key to retrieve the value and maintain continuity across requests.		
	It contains a unique session identifier(JSESSIONID) generated by the server (e.g., Tomcat).
	Always use HttpOnly, Secure, and SameSite flags for JSESSIONID to prevent hijacking.


Why do we need Session Management:
----------------------------------
	HTTP is a stateless protocol, meaning each request from a client to the server is independent of any previous requests. 
	*How the server knows that the requests are coming from the same client or same user?

Diff b/w Session management and Transaction management:
-------------------------------------------------------
	Session: 		You walk into the bank and interact with the teller.
	Transaction: 	Each deposit or withdrawal you make during that visit.

	Session: 		is about 'user continuity':	keeping track of who the user is and what they’re doing.
	Transaction: 	is about 'data integrity':	making sure operations are completed correctly or not at all.


Ways for Session Management:
----------------------------
	Method 						Pros 									Cons
	------						----									----
	Server-side sessions 		Easy to revoke, secure 					Requires server storage
	JWTs + refresh token 		Stateless, scalable 					Complex to secure and revoke
	OAuth2 + opaque tokens 		Centralized control via auth server 	Needs external provider

There are three primary ways to implement server-side session management in a Spring-based application:
-------------------------------------------------------------------------------------------------------
	1. HttpSession 					(Servlet-based, Stateful)
	2. Spring Session 				(Distributed, Scalable)
	3. Custom Session Management 	(JWT, OAuth) (Stateless)
	
	Clarifying the Terminology:
	---------------------------
		Spring Session itself is not stateless, it still stores session data.
		But it enables stateless application servers by moving session state out of the server and into a shared store.	

	Summary Table:
	--------------
		Approach 				Storage 		Scalability 	Complexity 	Best For
		--------				-------			-----------		----------	---------
		HttpSession 			In-memory 		Low 			Low 		Monolithic apps
		Spring Session 			Redis/JDBC/etc. High 			Medium 		Microservices, distributed apps
		Custom Implementation 	Custom DB/cache High 			High 		Highly customized systems
		

		HttpSession		(Uses: HttpSession)
		SpringSession	(Uses: @EnableRedisHttpSession)
		
		
	Session Tracking Mechanisms:
	----------------------------
		Method 				Description 							Pros & Cons
		------				-----------								-----------
		Cookies 			Stores:  session ID in browser cookie 	Easy to use, Can be disabled
		URL Rewriting 		Appends: session ID to URLs 			Works without cookies, Less secure
		Hidden Form Fields 	Embeds:  session ID in form inputs 		Simple, Only works with forms
		
		
What Happens Behind the Scenes:
-------------------------------
	The servlet container (like Tomcat) handles the actual creation and management of the session object.
	It assigns a unique session ID(JSESSIONID) and sends it to the client 'via a cookie: Set-Cookie'.
	On subsequent requests, the client sends this ID back, allowing the server to retrieve the session.		


Session with Spring Security:
-----------------------------
	public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
				http.httpBasic(withDefaults())
					.sessionManagement(httpSecuritySessionManagementConfigurer -> 		httpSecuritySessionManagementConfigurer.sessionCreationPolicy(SessionCreationPolicy.ALWAYS))
					.authorizeRequests((authorizeRequests) -> authorizeRequests.requestMatchers("/")
						.hasRole("ADMIN")
						.anyRequest()
						.authenticated());
				return http.build();
				
	Session Creation Policies:
	--------------------------
		Always: 		The session will always be created if one does not exist.
		Never: 			The framework will never create the session but it will use one if it already exists.
		If_Required: 	Spring Security will only create the session when required(default).
		Stateless: 		No session will be used and created by Spring Security.					

Spring Session: What Does It Use?
---------------------------------
	By default, Spring Session also uses a cookie named SESSION instead of JSESSIONID.

	Framework 		Default Cookie Name 	Purpose
	---------		-------------------		-------
	HttpSession 	JSESSIONID 				Tracks session ID for server-side session, tied to a servlet container.
	Spring Session 	SESSION 				Tracks session ID, but "decoupled from servlet container"	


By default, Spring Session uses:
	UuidSessionIdGenerator — which internally uses java.util.UUID to generate a unique session ID.

You can plug in your own logic by implementing the SessionIdGenerator interface

Spring Session uses NoSQL while HttpSession uses sql for storing session data

HttpSession tied to Servlet Container while Spring Session decouples session management from the servlet container, making it portable, scalable, and cloud-friendly.

Spring Boot uses Servlet container-based session management by default (e.g., Tomcat, Jetty). 

Spring Boot provides various mechanisms for managing sessions: 
--------------------------------------------------------------
	In-Memory Sessions: 		Stores session data in the server’s memory(RAM).
	JDBC-Based Sessions: 		Stores session data in a relational database.
	Redis-Based Sessions: 		Stores session data in Redis, which allows for better scalability.
	Session Cookies: 			Spring Boot uses cookies by default to store the session ID on the client side.
		
When to Use What:
-----------------
	Use Spring Boot's default if you're building a simple monolith or don't need distributed session management.
		
	Use Spring Session if you're building microservices, need session replication, or want centralized control over sessions.

Session Management vs User Authentication:
------------------------------------------
	Think of authentication as the door check — proving you’re allowed in.
	Think of session management as the hall pass — letting you move around without re-authenticating.
	
	
Diff b/w JSESSIONID and Bearer token:
-------------------------------------
	Let's break down the difference between JSESSIONID and a Bearer token, as they represent two distinct approaches to managing user sessions and authentication.
	
	JSESSIONID:		Session Identifier
	Bearer Token: 	Access Token (often a JWT)


JWT/Opaque or OAuth tokens:
---------------------------
	JWT/Opaque are token format while OAuth is a protocol.
	JWTs/Opaque are often used within OAuth as a format for access tokens. 
	
		These access tokens can be:
		---------------------------
			Opaque tokens (random strings, validated via introspection).
			JWTs (self-contained, validated via signature).

	
Auth0 is a IAM Platform while OAuth is a protocol.			

	Tokens Returned by Auth0(OAuth 2.0 Protocol + OIDC Protocol):
	-------------------------------------------------------------
		ID Token: 					Contains user identity (name, email, etc.)
		Access Token: 				Used to access protected resources
		Refresh Token (optional): 	Used to get new access tokens without re-login

OAuth 2.0 is a protocol for authorization, not authentication or session management.

	Common Misconception:
	---------------------
		Many developers mistakenly use OAuth as an authentication protocol. While it can be combined with OpenID Connect (OIDC) to support authentication, OAuth itself does not manage sessions.


OpenID Connect and OAuth 2.0 are two diff protocols used for authentication and authorization purpose respectly.
OICD extends OAuth 2.0 to include authentication.
OIDC is a layer built on top of OAuth 2.0 that adds identity verification.

OAuth lets apps access data. OpenID Connect lets apps know who you are.

Access Token is generated by OAuth2.0 protocol and ID Token is generated by OpenID Connect (OIDC) protocol

		Summary Table:
		--------------
		Protocol 		Purpose 						Identity Info	Token Type 		Use Case Example 
		--------		-------							-------------	----------		----------------
		OAuth 2.0 		Authorization 					No				Access Token 	App accessing user's calendar
		OpenID Connect 	Authentication + Authorization 	Yes 			ID Token +  	App logging in user via Google

	Auth0 acts as the Authorization Server in the OAuth 2.0 framework and supports OpenID Connect (OIDC) on top of OAuth 2.0 to enable authentication.


			  
Authorization server can generate tokens in two format: JWT or Opaque token.

If you're building an app, the choice depends on your architecture:
-------------------------------------------------------------------
	1. JWTs: 			for stateless APIs and microservices.					(one way of token format type)
	2. Opaque tokens: 	if you want centralized control and easy revocation.	(another way of token format type)
	
	
Token verification:
-------------------
	JWT : 			Can be verified locally using public keys (no need to call the auth server.)
	Opaque token: 	The resource server must call the authorization server to validate and get details about the token.	
	
	
Diff b/w JWT, Opaque token and Session token:
---------------------------------------------
	Commonly JWT and Opaque token are used for authentication and authorization purpose while session token is used to maintain the user's state across multiple requests.


	Note:
		Session Token cann't be stateless because it's stored on server's memory and for stateless, it needed sticky sessions or session token replication mechanism which is bit complex, still not a good option for stateless or scalability.			  
			  
			  
Diff b/w authorization code, id token and access token ?
--------------------------------------------------------
		Authorization code: A temporary code issued to the client after the user successfully authenticates.
		ID Token:			Used for authentication purpose generated by OpenID Connect.	(JWT)
		Access Token: 		Used for authorization purpose generated by OAuth 2.0.			(opaque or JWT)			  
			  
	Summary Table:
	--------------
		Token Type 			Format 					Purpose 				Used By 			Can Access APIs?
		----------			------					-------					-------				----------------	
		Authorization Code 	Short string 			Exchange for tokens 	OAuth client 		No
		ID Token 			JWT 					Authentication 			Client app 			No
		Access Token 		JWT/Opaque 				Authorization 			Resource server 	Yes			  
			  
			  
Diff b/w ID Token and Access Token:
-----------------------------------
	Real-World Analogy:
	-------------------
		ID Token 		= 	Passport (proves who you are)
		Access Token 	= 	Visa (grants permission to enter specific places

	Summary:
	--------
		Token Type 		Purpose 		Sent to API? 
		----------		-------			------------
		ID Token 		Authentication 	No
		Access Token 	Authorization 	Yes
	
	
	Summary Table:
	--------------
		Token Type 	Generated By 		Purpose 			Stored Where
		----------	------------		-------				------------
		ID Token 	Identity Provider 	Authentication 		Client (e.g., localStorage)
		Session ID 	Application Server 	Session Management 	Server + Client Cookie				  
			  
			  
you do not need to send both the ID token and access token to call or access an API. You should only send the access token when making API requests.

	Summary Table:
	--------------
		Token Type 		Self-contained 	Validation Method 			Common Use Case 			Revocation Ease
		----------		--------------	-----------------			---------------				---------------
		Opaque Token 	No 				Server-side introspection 	OAuth2 APIs 				Easy
		JWT 			Yes 			Local signature check 		OAuth2/OIDC, microservices 	Hard 
		Session Token 	No 				Server-side session lookup 	Web app login sessions 		Easy 
			  
		
Can an ID Token Be Used Like a Session ID?
------------------------------------------
	Technically, yes—you can use an ID token to maintain a session, especially in stateless architectures like SPAs (Single Page Applications). 
	But:
		- It’s not a traditional session ID.
		- It doesn’t point to server-side session data.
		- It’s self-contained (JWT), so the app must validate it on every request or store it securely.

	Think of it like this:
		Session ID 	= key to a locker (server holds the contents)
		ID Token  	= a sealed envelope with everything inside (no locker needed)	(Token Type: JWT)

	Summary Table:
	--------------
		Token Type 	Generated By 		Purpose 			Stored Where
		----------	------------		-------				------------
		ID Token 	Identity Provider 	Authentication 		Client (e.g., localStorage)
		Session ID 	Application Server 	Session Management 	Server + Client Cookie		
			  
	
		Summary Table:
		--------------
			Token Type 		Self-contained 	Validation Method 			Common Use Case 			Revocation Ease
			----------		--------------	-----------------			---------------				---------------
			Opaque Token 	No 				Server-side introspection 	OAuth2 APIs 				Easy
			JWT 			Yes 			Local signature check 		OAuth2/OIDC, microservices 	Hard 
			Session Token 	No 				Server-side session lookup 	Web app login sessions 		Easy 
			  
			  
Can an Authorization Server Generate a Session ID?
--------------------------------------------------
	Technically, Yes—But It’s Not Typical:
	--------------------------------------
		While an authorization server (like Google, Auth0, or Microsoft Entra ID) can issue tokens (ID tokens, access tokens, refresh tokens), it does not usually generate session IDs in the traditional sense used for server-side session management.
		
		However, in custom implementations or advanced flows, the authorization server can issue a session-like token—often a JWT—that behaves like a session ID. This is especially common in Backend-for-Frontend (BFF) architectures or token-based session management.

	OAuth + OpenID Connect Login Flow:
	-------------------------------------
		
		[1] User clicks "Login with Provider"
				↓
		[2] Client App redirects to Authorization Server (e.g., Google/Auth0/Okta)
				↓
		[3] User authenticates (enters credentials)
				↓
		[4] Authorization Server redirects back to Client App with:
				Authorization Code
				↓
		[5] Client App sends Authorization Code to Authorization Server
				Along with Client ID & Secret
				↓
		[6] Authorization Server responds with:
				Access Token (OAuth)
				ID Token (OpenID Connect, usually a JWT)
				Optional Refresh Token
				↓
		[7] Client App stores tokens securely
				Access Token: used for API calls
				ID Token: used to identify the user
				Refresh Token: used to renew access token
				↓
		[8] Session is maintained via:
				Short-lived access token
				Refresh token rotation
				Optional HttpOnly cookie for refresh token
			  

-------------------
Structure of a JWT:
-------------------
	JWTs consist of three parts:	
		header.payload.signature

	Part 		Contents 							Purpose 
	----		--------							-------
	Header 		Algorithm & token type 				Tells how the token is signed
	Payload 	Claims (e.g. user ID, roles, exp) 	Holds the actual data
	Signature 	Signed using secret/key 			Verifies token integrity

	
	Basic JWT Implementation Flow:
	------------------------------
		1. User Logs In:
		----------------
			User submits credentials to your login API (e.g., /api/login).
			Backend verifies them and generates a JWT containing user info (id, role, etc.).
		
		2. Backend Issues JWT:
		----------------------
			Create a token using a library (e.g., jsonwebtoken in Node.js or pyjwt in Python).
			Sign the token with a secret key.
			Send it back to the client (usually in response JSON or a cookie).
		
		3. Client Stores JWT:
		---------------------
			Store it securely:
			For web apps: HttpOnly cookie is recommended.
			For mobile: Secure storage like Keychain (iOS) or Keystore (Android).
		
		4. Client Sends JWT with API Requests:
		--------------------------------------
			Attach JWT in Authorization header:
				
			Authorization: Bearer <your-jwt-token>

		5. Backend Validates JWT:
		-------------------------
			On each protected API call, decode and verify JWT.
			Check signature, expiry (exp), and any custom claims.
			If valid, proceed. If not, respond with 401 Unauthorized.
		
		6. Token Expiry & Refresh:
		--------------------------
			Use short-lived access tokens (e.g., 15 mins).
			Provide a refresh token (longer life, stored securely).
			When access token expires, client calls a refresh endpoint to get a new one.


	Send Token in Requests:
	--------------------------
		Use Postman or frontend to send:
		Authorization: Bearer <your_token>

The generation of JWTs should always be handled by a trusted backend or authentication server—never by the client.			
The client is inherently untrusted—anyone can inspect or manipulate it.

	Use Refresh Tokens:
	------------------------------
		Access tokens (JWTs) should be short-lived.
		Use a refresh token (stored securely, ideally in an HttpOnly cookie) to get new access tokens without re-authenticating.			 
			 
JWTs can be used for both authentication and session management although JWTs Are Not Ideal for Session Management because it's Hard to Revoke and no server-side control.
	
	
			  
			  
			  
			  
			  
			  
			  
============================================================================================================================
=======================================================START================================================================
============================================================================================================================


What Are Browser Cookies?:
--------------------------
	Cookies are small 'text files' stored by the browser on the user's device. 
	Each cookie is a key-value pair with optional metadata like: expiration, path, domain, and security flags.
	
	They are used for:
	------------------
		Maintain sessions
		Authenticate users
		Store user preferences
		Track user behavior

	
	Cookie Attributes:
	------------------
		Attribute 	Purpose
		---------	-------
		HttpOnly 	Prevents access via JavaScript (XSS defense)
		Secure 		Sends cookie only over HTTPS
		SameSite 	Controls cross-site request behavior (CSRF defence)	
		Expires 	Sets expiration date
		Path 		Limits cookie to specific URL path
		Domain 		Specifies domain for which cookie is valid

	
	How Cookies Work Internally:
	----------------------------
		1. Creation:
		------------
			Cookies are set by the server via the Set-Cookie HTTP header:
				Set-Cookie: sessionId=abc123; Path=/; HttpOnly; Secure; SameSite=Strict
			
			Or by Client-Side JavaScript:
				document.cookie = "theme=dark; expires=Fri, 31 Dec 2025 23:59:59 GMT; path=/";

		2. Storage Location:	
		--------------------
			Cookies are stored in the browser's "internal cookie store".
			
			Each browser has its own implementation:
				Chrome: 	Stored in SQLite databases under the user profile directory.
				Firefox: 	Stored in cookies.sqlite.
				Safari: 	Stored in binary plist files.
		
			You can view cookies in browser dev tools:
				Chrome: 	DevTools → Application → Cookies
				Firefox: 	DevTools → Storage → Cookies
		
		3. Transmission:
		----------------
			Cookies are automatically sent with every HTTP request to the matching domain and path.
		
		4. Expiration:
		--------------
			Session cookies: 	Deleted when the browser/tab is closed.
			Persistent cookies: Stored until the expiration date or manually deleted.


		Security Considerations:
		------------------------
			Use HttpOnly and Secure for sensitive cookies (e.g., session tokens).
			Set SameSite=Strict or Lax to prevent CSRF.
			Avoid storing sensitive data directly in cookies, use tokens or session IDs.


Session Cookie vs Persistent Cookie:
------------------------------------
	Type 				Behavior
	----				--------
	Session Cookie 		Expires when the browser is closed
	Persistent Cookie 	Remains until a specified expiration date/time
	
	
	1. Setting a Session Cookie:
	----------------------------
		A session cookie is created without an expiration date:

			 Cookie sessionCookie = new Cookie("sessionId", "abc123");
					sessionCookie.setPath("/");
					sessionCookie.setHttpOnly(true); 			// Optional: for security
					response.addCookie(sessionCookie);

		Notes:
			No setMaxAge() means it’s a session cookie.
			It will be deleted when the browser is closed.
	
	2. Setting a Persistent Cookie:
	-------------------------------
		A persistent cookie is created by setting a Max-Age or Expires attribute:

			Cookie persistentCookie = new Cookie("sessionId", "xyz789");
			persistentCookie.setPath("/");
			persistentCookie.setHttpOnly(true);
			persistentCookie.setMaxAge(60 * 60 * 24 * 30); 		//setting a Max-Age or Expires: 30 days
			response.addCookie(persistentCookie);

		Notes:
			setMaxAge() defines how long the cookie will live (in seconds).
			The browser stores it even after closing.


Diff b/w manually setting a session ID in a cookie and relying on the server-generated JSESSIONID:
--------------------------------------------------------------------------------------------------
	
	1. Manually Setting Session ID in Cookie:
	-----------------------------------------
		You create a cookie manually and set a value for JSESSIONID or another name.
		
		Unless the server recognizes this ID and has a corresponding session stored, it won’t associate it with any session.
		If the session ID was not previously issued by the server, request.getSession(false) will return null.
		
		Example Issue:
		--------------
			From a real-world case:
				“The client sets Cookie: JSESSIONID=xyz, but request.getSession(false) returns null because the server doesn’t recognize that session ID”.

	
	2. Server-Generated JSESSIONID:
	-------------------------------
		When a client first accesses a server (e.g., Tomcat), the server creates a session using HttpServletRequest.getSession(true).
		
		The server generates a unique session ID (e.g., JSESSIONID) using a secure algorithm (often combining random values, timestamps, and JVM identifiers).
		
		This ID is sent back to the client as a cookie, typically named JSESSIONID.
		
		On subsequent requests, the client sends this cookie, and the server uses it to retrieve the session from memory or a persistent store.
		
		Key Benefits:
			Secure and consistent session lifecycle.
			Session data is stored server-side, only the ID is sent to the client.
			Automatic session invalidation via timeout or session.invalidate().
	
	
	Best Practice:
	--------------
		Always let the server generate and manage session IDs unless you have a very specific use case (e.g., custom client integration or debugging). 
		Manually setting session IDs can lead to security risks and session mismatches.


Diff b/w JSESSIONID and the session data stored on the server:
--------------------------------------------------------------
	Summary:
	--------
		JSESSIONID is the key.
		Session data is the value stored securely on the server.
		The server uses the key to retrieve the value and maintain continuity across requests.

	What is JSESSIONID?
	-------------------
		JSESSIONID is a cookie sent to the client by the server.
		It contains a unique session identifier generated by the server (e.g., Tomcat).
		This ID is used to track the user's session across multiple HTTP requests.
		It does not contain any user data—just the key to look up the session.
	
		Think of JSESSIONID as a locker number. It tells the server which locker (session) to open, but doesn't contain the contents of the locker itself.
	
	What is Session Data?
	---------------------
		Session data refers to the actual information stored on the server for a user's session.
		This includes attributes like user ID, roles, preferences, shopping cart contents, etc.
		Stored in server memory, or optionally in Redis, database, or file system depending on configuration.
		
		Accessed via HttpSession object in Java:
		
			session.setAttribute("username", "john_doe");


	Key Differences:
	----------------
		Aspect 			JSESSIONID Cookie 						Session Data on Server
		------			-----------------						-----------------------
		Location 		Stored in browser cookie 				Stored in server memory or persistent store
		Content 		Unique session identifier 				User-specific data (e.g., login info)
		Purpose 		Identify session across requests 		Maintain state between requests
		Security Risk 	Can be hijacked if not secured properly Protected server-side
		Size 			Small (just an ID) 						Can be large depending on stored data


	Security Considerations:
	------------------------
		Always use HttpOnly, Secure, and SameSite flags for JSESSIONID to prevent hijacking.
		Session data should never be stored in cookies directly, only the ID should be.


Cookies vs localStorage:
------------------------
	Feature 				Cookies 										localStorage 
	-------					-------											------------
	Persistence 			Can be set to expire at a specific time or  	Persists until explicitly cleared by the user or
							session-based									script	
	
	Storage Limit 			~4KB per cookie 								~5–10MB per domain
	
	Server Communication 	Automatically sent with every HTTP request  	Not sent to the server; only accessible via 
							to the server									JavaScript
							
	Security 				Vulnerable to CSRF unless using HttpOnly  		Safer from CSRF, but still accessible via 
							and Secure flags								client-side scripts
							
	Use Case 				Authentication, personalization, tracking 		Storing non-sensitive client-side data like
																			preferences or form progress
																			
	Accessibility 			Accessible by both server and client  			Accessible only on the client side
							(unless HttpOnly)


Key Differences:
----------------
	Cookies: 
		are sent to the server with every request, making them ideal for things like session management and authentication—but they also add overhead.
	
	localStorage: 
		is great for storing large amounts of data that persist across sessions, like theme settings or saved drafts.
	
	SessionStorage: 
		is perfect for temporary data that should disappear when the user closes the tab, like form inputs or navigation state.

	Use cookies for: 			server-related data (e.g., login tokens).
	Use localStorage for: 		persistent client-side data. (e.g., preferences or form progress)
	Use sessionStorage for: 	temporary, tab-specific data


Security Considerations:
------------------------
	Cookies: 
	--------
		Can be made more secure using flags like:
			HttpOnly: Prevents access via JavaScript
			Secure: Ensures transmission only over HTTPS
	
	localStorage:
	-------------	
		Safer from CSRF but Vulnerable to XSS attacks since it's accessible via JavaScript. 
		

XSS Vs CSRF:
------------
	XSS (Cross-Site Scripting): HttpOnly
	------------------------------------
		Prevents access via JavaScript (XSS defense).
		
	CSRF (Cross-Site Request Forgery): SameSite
	-------------------------------------------
		Controls cross-site request behavior (CSRF defence).
		
		
	Core Difference:
	----------------
	Aspect 				XSS (Cross-Site Scripting): HttpOnly 				CSRF (Cross-Site Request Forgery): SameSite
	------				------------------------------------				-------------------------------------------
	Goal 				Execute malicious scripts in the user's browser 	Trick user into performing unintended actions
	
	Requires Login? 	No — can affect any user 							Yes — requires authenticated session
	
	Attack Vector 		Injected JavaScript or HTML into trusted web pages 	Exploits authenticated user's browser to send 
																			requests
	
	Impact Scope 		Broad — can steal data, hijack sessions, deface  	Limited — can only perform actions the 
						pages												user is authorized for
	
	User Interaction 	Often passive (just visiting a page) 				Requires user to click or load a malicious page
	
	Defense 			Input sanitization, Content Security Policy (CSP) 	CSRF tokens, SameSite cookies, double-submit 
																			cookies

============================================================================================================================


Diff b/w Session management and Transaction management:
-------------------------------------------------------
	Session: 		You walk into the bank and interact with the teller.
	Transaction: 	Each deposit or withdrawal you make during that visit.

	Session: 		is about 'user continuity':	keeping track of who the user is and what they’re doing.
	Transaction: 	is about 'data integrity':	making sure operations are completed correctly or not at all.

	Real-World Example:
	-------------------
		Imagine a user placing an order:
			Session keeps the user logged in and remembers their cart.
			Transaction ensures the order is placed, payment is processed, and inventory is updated — all or nothing.

	
	
Session: UI vs Backend:
-----------------------
	Aspect 		UI (Frontend) 										Backend
	------		-------------										-------
	Purpose 	Maintains user state across pages or interactions 	Manages user context and persistence across requests 
	Examples 	Logged-in user info, shopping cart, theme settings 	Auth tokens, user ID, preferences, cache
	Storage 	Browser cookies, localStorage, sessionStorage 		Server memory(RAM), Redis, database
	Lifecycle 	Starts:when user visits site, Ends:on logout/close 	Starts on: login or request, Ends on: logout/timeout
	Security 	Vulnerable to XSS, CSRF if not protected 			Secured via tokens, session IDs, HTTPS


Transaction: UI vs Backend:
---------------------------
	Aspect 			UI (Frontend) 										Backend
	------			-------------										-------
	Purpose 		Rarely used directly; may show progress or status 	Ensures atomic operations on data (e.g. DB updates)
	Examples 		“Processing payment…” message, spinner animation 	Bank transfer, order placement, inventory update
	Control 		UI triggers transaction via API call 				Backend handles begin, commit, rollback
	Error Handling 	Shows error message or retry option 				Rolls back changes if failure occurs



	
============================================================================================================================


Why do we need Session Management:
----------------------------------
	HTTP is a stateless protocol, meaning each request from a client to the server is independent of any previous requests. 
	
	*How the server knows that the requests are coming from the same client or same user?
	
	To overcome this, 
		session management: 'allows the server to retain information about a client across multiple requests', thereby creating a session. 
	
	Maintaining user state across multiple requests. 
	This session can be used to track user activity, store preferences, and maintain security contexts.
	
	Since HTTP is stateless, Java provides several mechanisms to track and persist session data.
	
	
Ways for Session Management:
----------------------------
	Method 						Pros 									Cons
	------						----									----
	Server-side sessions 		Easy to revoke, secure 					Requires server storage
	JWTs + refresh token 		Stateless, scalable 					Complex to secure and revoke
	OAuth2 + opaque tokens 		Centralized control via auth server 	Needs external provider

	
Ways to implement Server-side session management:
-------------------------------------------------
	Below methods would be used to manage HTTP sessions in Spring-based applications, but they serve different purposes and offer different levels of control.
	
	There are three primary ways to implement session management in a Spring-based application:
	-------------------------------------------------------------------------------------------
		1. HttpSession 					(Servlet-based, Stateful)
		2. Spring Session 				(Distributed, Scalable)
		3. Custom Session Management 	(JWT, OAuth) (Stateless)	
	
	
	1. HttpSession (Servlet-based, Stateful):
	-----------------------------------------
		The default session mechanism provided by the servlet container (e.g., Tomcat).
		
		How it works:
			Stores session data in the server’s memory.
			Identified by a JSESSIONID cookie.


	2. Spring Session (Distributed, Scalable):
	------------------------------------------
		Replaces HttpSession with a more flexible, pluggable session management system.
		Great for clustered environments and microservices.
		
		How it works:
			Stores session data in Redis, JDBC, MongoDB, etc.
			Enables session sharing across multiple app instances.

	3. Custom Session Management:
	-----------------------------
		You build your own session handling logic using tokens, databases, caches (Redis, Memcached), or in-memory stores.
		Store sessions in Redis or database for scalability.
		Implement JWT (JSON Web Tokens) for 'stateless session handling' in REST APIs.
		
		How it works:
			Often involves issuing JWTs or opaque tokens.
			Offers full control over session lifecycle, storage, and security.
			You manage session lifecycle, storage, and validation manually.
			

	Summary Table:
	--------------
		Approach 				Storage 		Scalability 	Complexity 	Best For
		--------				-------			-----------		----------	---------
		HttpSession 			In-memory 		Low 			Low 		Monolithic apps
		Spring Session 			Redis/JDBC/etc. High 			Medium 		Microservices, distributed apps
		Custom Implementation 	Custom DB/cache High 			High 		Highly customized systems

	
	When to Use What?
	-----------------
		Use Case 							Recommended Approach
		--------							--------------------	
		Simple web app 						HttpSession or Cookies
		RESTful API 						JWT or OAuth tokens
		Stateless architecture 				Token-based (JWT)
		Distributed system 					Spring Session with Redis
		Enhanced security & scalability 	Custom session manager	
	
	
HttpSession is for stateful application while SpringSession is for stateless application?
------------------------------------------------------------------------------------------
	HttpSession vs Spring Session: Stateful vs Stateless?
	
	HttpSession is inherently stateful:
	-----------------------------------
		It stores session data in memory of the servlet container (e.g., Tomcat).
		Each session is tied to a specific server instance.
		If you scale horizontally (multiple servers), you need sticky sessions or session replication, which adds complexity.
		
		HttpSession is ideal for monolithic or single-server applications where state is managed locally.


	Spring Session enables stateless architecture:
	----------------------------------------------
		It externalizes session storage to systems like Redis or JDBC.
		This allows multiple app instances to share session data without relying on in-memory state.
		You can build stateless services that don’t store session data locally but still maintain user sessions via a centralized store.
		
		Spring Session is designed for distributed, cloud-native, or microservices architectures.

	Clarifying the Terminology:
	---------------------------
		Spring Session itself is not stateless, it still stores session data.
		But it enables stateless application servers by moving session state out of the server and into a shared store.
	
============================================================================================================================
	
	
1. HttpSession (Servlet-based, Stateful):
-----------------------------------------	

	Why HttpSession Is Useful:
	--------------------------
		State Maintenance: 	Tracks user-specific data like login status, preferences, or shopping carts.
		Security: 			Helps enforce access control by checking session attributes.
		Convenience: 		Simplifies user experience by maintaining continuity across pages


	Implementation:
	---------------
		1.	HttpSession session = request.getSession(); 				// creates or retrieves session
		2.	session.setAttribute("username", "john_doe"); 				// store data
		3.	String user = (String) session.getAttribute("username"); 	// retrieve data
		4.	session.invalidate(); 										// destroy session

		Automatically creates a session ID (JSESSIONID) stored in a cookie.
		Works seamlessly with most servlet containers (Tomcat, Jetty, etc.).
	
	
	How HttpSession Maintains State:
	--------------------------------
		1. Session Creation:
		--------------------
			When a user first accesses a web application, the server creates a new HttpSession object.
			This is typically done via request.getSession() in a servlet or controller.
		
		2. Session ID Assignment:
		-------------------------
			The server generates a unique session ID(JSESSIONID) for the user.
			This ID is stored on the server and sent to the client via a Set-Cookie header.
		
		3. Client Stores Session ID:
		----------------------------
			The browser stores the session ID in a cookie.
			On subsequent requests, the browser automatically sends this cookie back to the server, allowing the server to retrieve the correct session.
		
		4. Server Retrieves Session:
		----------------------------
			The server reads the session ID from the incoming request.
			It uses this ID to retrieve the corresponding HttpSession object from memory.
		
		5. Session Attributes:
		----------------------
			Developers can store user-specific data (like username, cart items, etc.) using:
				
				session.setAttribute("username", "JohnDoe");
		
			This data persists across requests until the session expires or is invalidated.

		
		Example Cookie Header:
		----------------------	
			Set-Cookie: JSESSIONID=1A530637289A03B07199A44E8D531427; Path=/; HttpOnly

				Note: JSESSIONID is a combination of random values, timestamps, and JVM identifiers.


	Session Tracking Mechanisms:
	----------------------------
		Method 				Description 							Pros & Cons
		------				-----------								-----------
		Cookies 			Stores:  session ID in browser cookie 	Easy to use, Can be disabled
		URL Rewriting 		Appends: session ID to URLs 			Works without cookies, Less secure
		Hidden Form Fields 	Embeds:  session ID in form inputs 		Simple, Only works with forms		


	Key Features of HttpSession:
	----------------------------
		Session Creation and Management: 
			Automatically creates and manages a session for each client.
		
		Session ID: 
			Each session is identified by a unique session ID stored on the client (usually as a cookie) and sent to the server with every HTTP request.
		
		Attribute Storage: 
			The session allows the storage of key-value pairs.
			
		Session Timeout: 
			Automatically invalidates a session after a defined period of inactivity.
			
		Session Invalidation: 
			Sessions can be manually invalidated for security or logout purposes.


	Key Methods of HttpSession:
	---------------------------
		getId(): 									Returns the unique session ID.
		setAttribute(String key, Object value): 	Stores a session attribute.
		getAttribute(String key): 					Retrieves the session attribute.
		removeAttribute(String key): 				Removes a session attribute.
		invalidate(): 								Invalidates the session.
		getMaxInactiveInterval(): 					Gets the session timeout.
		setMaxInactiveInterval(int interval): 		Sets the session timeout.	


	Best Practices:
	---------------
		Secure your session: 			Use HTTPS, set HttpOnly and Secure flags on cookies.
		Set session timeout: 			Configure in web.xml or programmatically.
		Invalidate on logout: 			Always call session.invalidate() to prevent reuse.
		Avoid storing sensitive data: 	Keep session data minimal and encrypted if needed.
		
	
When a user first accesses a web application, the server creates a new HttpSession object automatically or we need to do some coding ?
----------------
		The creation of an HttpSession in a Java web application is not automatic unless you explicitly request it in your code.
			
			1. The session is created when you call:	
			----------------------------------------	
				HttpSession session = request.getSession();
				
					- It Returns the current session associated with the request.
					- If no session exists, it creates a new one

			2. Alternatively, you can use:
			------------------------------		
				HttpSession session = request.getSession(false);

					- This version:
						- Returns the current session only if it exists.
						- Returns null if no session is present.
			
			What Happens Behind the Scenes:
			-------------------------------
				The servlet container (like Tomcat) handles the actual creation and management of the session object.
				It assigns a unique session ID(JSESSIONID) and sends it to the client 'via a cookie: Set-Cookie'.
				On subsequent requests, the client sends this ID back, allowing the server to retrieve the session.



============================================================================================================================

2. Spring Session (Distributed, Scalable):
------------------------------------------
	Spring Session is a powerful tool for managing HTTP sessions. 
	
	Spring Session has the simple goal of free up session management from the limitations of the HTTP session stored in the server.

	The solution makes it easy to share session data between services in the cloud without being tied to a single container (i.e. Tomcat). 
	Additionally, it supports multiple sessions in the same browser and sending sessions in a header.

	1)
	Let’s add some configuration properties for our Redis server in application.properties:
		spring.redis.host=localhost
		spring.redis.port=6379
	
	2)
	For Spring Boot, it’s enough to add the following dependencies, and the auto-configuration will take care of the rest:

		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-data-redis</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.session</groupId>
			<artifactId>spring-session-data-redis</artifactId>
		</dependency>
		
	3)
	Now let’s add a configuration class for Spring Session:

		@Configuration
		@EnableRedisHttpSession
		public class SessionConfig extends AbstractHttpSessionApplicationInitializer {
			@Bean
			public JedisConnectionFactory connectionFactory() {
				return new JedisConnectionFactory();
			}
		}	
		
		@EnableRedisHttpSession and the extension of AbstractHttpSessionApplicationInitializer will create and wire up a filter in front of all our security infrastructure to look for active sessions and populate the security context from values stored in Redis.
		
	4)
	Let’s now complete this application with a controller and the security config.

		@RestController
		public class SessionController {
			@RequestMapping("/")
			public String helloAdmin() {
				return "hello admin";
			}
		}		
			
		This will give us an endpoint to test.	
		
	5) 
	Next, add our security configuration class:

		@Configuration
		@EnableWebSecurity
		public class SecurityConfig {

			@Bean
			public InMemoryUserDetailsManager userDetailsService(PasswordEncoder passwordEncoder) {
				UserDetails user = User.withUsername("admin")
					.password(passwordEncoder.encode("password"))
					.roles("ADMIN")
					.build();
				return new InMemoryUserDetailsManager(user);
			}

			@Bean
			public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
				http.httpBasic(withDefaults())
					.sessionManagement(httpSecuritySessionManagementConfigurer -> 		httpSecuritySessionManagementConfigurer.sessionCreationPolicy(SessionCreationPolicy.ALWAYS))
					.authorizeRequests((authorizeRequests) -> authorizeRequests.requestMatchers("/")
						.hasRole("ADMIN")
						.anyRequest()
						.authenticated());
				return http.build();
			}
			
			@Bean
			public PasswordEncoder passwordEncoder() {
				return new BCryptPasswordEncoder();
			}
		}
		
		This protects our endpoints with basic authentication and sets up a user to test with.


	Key terminologies:
	------------------
		Session Creation Policies:
		--------------------------
			Always: 		The session will always be created if one does not exist.
			Never: 			The framework will never create the session but it will use one if it already exists.
			If_Required: 	Spring Security will only create the session when required(default).
			Stateless: 		No session will be used and created by Spring Security.	
			
			(Note: looks similar like transaction propagation policy)
			

	Control the Session with Spring Security:
	-----------------------------------------
		@Configuration
		@EnableWebSecurity
		public class SecurityConfig  {

			protected void configure(HttpSecurity http) throws Exception {
						http
						.authorizeRequests()
						.anyRequest().authenticated()
						.and()
						.formLogin()
						.loginPage("/login").permitAll()
						.defaultSuccessUrl("/home", true)
						.and()
						.logout()
						.logoutSuccessUrl("/login?logout")
						.and()
						.sessionManagement()
						.maximumSessions(1)					//After session expired, you have been logged out.
						.maxSessionsPreventsLogin(true);
			}
		}
	

============================================================================================================================

	
HttpsSession tied to a single container(tomcat) while Spring Session doesn't:
-----------------------------------------------------------------------------
	
	HttpSession vs Spring Session:
	------------------------------
	
	Feature 				HttpSession (Tomcat) 						Spring Session 
	-------					--------------------						--------------
	Session Storage 		Stored in memory of the servlet container 	Stored in external data store (e.g., Redis, JDBC)
	Container Dependency 	Tied to a single container (e.g., Tomcat) 	Container-neutral; works across multiple nodes 
	Scalability 			Limited to one server or sticky sessions 	Supports distributed sessions out of the box
	Session Sharing 		Not shared across instances 				Shared across services and containers
	Persistence 			Lost on server restart unless configured 	Can persist sessions across restarts 
	Use Case 				Simple monolithic apps 						Microservices, cloud-native apps

	
	Why HttpSession Is Tied to a Single Container:
	----------------------------------------------
		The session data is stored in memory of the servlet container (e.g., Tomcat).
		If you deploy your app across multiple servers, each server has its own session store.
		This means users may lose their session if routed to a different server—unless you use sticky sessions or external session replication.

	Why Spring Session Is More Flexible:
	------------------------------------
		Spring Session replaces the default HttpSession with a distributed implementation.
		You can back it with Redis, JDBC, Hazelcast, etc.
		This allows session sharing across multiple instances, making it ideal for cloud and microservice environments.


HttpSession uses JSESSIONID but what SpringSession uses to track the session?
------------------------------------------------------------------------------
	HttpSession (the standard Java EE session mechanism) typically uses a cookie named JSESSIONID to track the session. When it comes to Spring Session, things get a bit more flexible and powerful.

	Spring Session: What Does It Use?
	---------------------------------
		By default, Spring Session also uses a cookie named SESSION instead of JSESSIONID.

	Framework 		Default Cookie Name 	Purpose
	---------		-------------------		-------
	HttpSession 	JSESSIONID 				Tracks session ID for server-side session, tied to a servlet container.
	Spring Session 	SESSION 				Tracks session ID, but "decoupled from servlet container"

	How to Customize the Cookie Name:
	----------------------------------
		1. You can change the default cookie name (SESSION) in Spring Boot using properties:
			
			server.servlet.session.cookie.name=MYSESSIONID
	
		2. if you're using Spring Session with Redis:
			@Bean
			public CookieSerializer cookieSerializer() {
				DefaultCookieSerializer serializer = new DefaultCookieSerializer();
				serializer.setCookieName("MYSESSIONID");
				return serializer;
			}


	Why the Change?
	---------------
		Spring Session replaces the standard HttpSession with a more customizable and distributed session management system. 
		It allows you to:
			Store sessions in Redis, JDBC, Hazelcast, etc.
			Share sessions across multiple servers (great for microservices)
			Customize cookie name, expiration, and behavior


How session id is generated in spring session so that it decoupled from servlet container?
------------------------------------------------------------------------------------------
	Spring Session generates session IDs in a way that is decoupled from the servlet container by using its own SessionIdGenerator interface. 
	This allows Spring Session to manage session identifiers independently of the default JSESSIONID mechanism used by servlet containers like Tomcat.
	
	1. How Spring Session Generates Session IDs:
	--------------------------------------------
		By default, Spring Session uses:
		
			UuidSessionIdGenerator — which internally uses java.util.UUID to generate a unique session ID.

		This ensures:
			Global uniqueness
			No dependency on servlet container
			Compatibility with distributed session stores like Redis, JDBC, etc.

	
	2. Customizing Session ID Generation:
	-------------------------------------
		You can plug in your own logic by implementing the SessionIdGenerator interface:
			
			class MySessionIdGenerator implements SessionIdGenerator {
				@Override
				public String generate() {
					// Custom logic, e.g., using SecureRandom or hashing
					return UUID.randomUUID().toString();
				}
			}


Alternatives to UuidSessionIdGenerator:
---------------------------------------
	Spring Session uses UuidSessionIdGenerator by default, but there are several compelling alternatives you can consider depending on your needs for security, performance, or sortability:
	
		1. NanoID
		2. ULID 
		3. KSUID
		4. CUID 


	How to Use These in Spring Session:
	-----------------------------------
		You can implement a custom SessionIdGenerator using any of these:

			@Bean
			public SessionIdGenerator sessionIdGenerator() {
				return () -> NanoIdUtils.randomNanoId(); // or ULID.random(), etc.
			}


	
Spring Session uses NoSQL while HttpSession uses sql for storing session data why?:
-----------------------------------------------------------------------------------
	you're absolutely right. Here's a clear explanation of why Spring Session often uses NoSQL (like Redis), while traditional HttpSession typically uses SQL or in-memory storage:
	
	HttpSession: Tied to Servlet Container
	--------------------------------------
		Default Behavior: 
			In servlet containers like Tomcat, HttpSession stores session data in memory.
		
		SQL Option: 
			You can configure it to persist sessions in a relational database using JDBC, but this is not automatic.
		
		Limitation: 
			It's tied to a single server instance, which makes it hard to scale horizontally without sticky sessions or replication.
		
		HttpSession is stateful and container-bound, making it less ideal for distributed systems.


	Spring Session: Designed for Scalability:
	-----------------------------------------
	Pluggable Backends: Spring Session supports multiple storage options:
		Redis (NoSQL) – default and most popular
		JDBC (SQL) – for relational databases
		Hazelcast, MongoDB, etc.
	
	Why NoSQL like Redis?
		High performance: 		Redis is an in-memory key-value store, perfect for fast session lookups.
		Built-in TTL: 			Sessions can expire automatically.
		Distributed support: 	Works across multiple app instances—ideal for cloud-native apps.
		Stateless architecture: Enables load balancing without sticky sessions.
	
	Spring Session decouples session management from the servlet container, making it portable, scalable, and cloud-friendly.


============================================================================================================================

Difference between Spring Session and Spring Boot's built-in session management:
--------------------------------------------------------------------------------
	Both are used to manage HTTP sessions in Spring-based applications, but they serve different purposes and offer different levels of control.
	
	SpringBoot:
	------------
		Spring Boot uses Servlet container-based session management by default (e.g., Tomcat, Jetty). 
		
		Here's what it offers
			Session stored in memory (or optionally in Redis, JDBC, etc. via configuration).
			Works well for simple use cases and monolithic applications.

		Limitations:
		------------
			Tied to the servlet container.
			Not ideal for distributed systems or microservices.
			Limited control over session persistence and sharing.

	Spring Session:
	---------------
		Decouples session management from servlet container.
		Supports Redis, JDBC, MongoDB, Hazelcast, etc.
		Enables session sharing across services (great for microservices).
		Provides cluster-safe session management.
		Supports Spring Security integration for storing security context.
	
		Use Case Example:
			You might use Spring Session with Redis to store sessions centrally:

		Advantages:
		-----------
			Centralized session store.
			Scalable and distributed.
			Works across multiple applications (e.g., SSO scenarios).


	When to Use What:
	-----------------
		Use Spring Boot's default if you're building a simple monolith or don't need distributed session management.
		
		Use Spring Session if you're building microservices, need session replication, or want centralized control over sessions.


============================================================================================================================
		
https://www.geeksforgeeks.org/advance-java/spring-boot-session-management/
https://www.baeldung.com/spring-session
https://www.geeksforgeeks.org/advance-java/control-the-session-with-spring-security/

Spring Boot - Session Management:
---------------------------------
	Maintaining user state across multiple requests.
	Since HTTP is stateless, Java provides several mechanisms to track and persist session data. 

	Spring Boot provides various mechanisms for managing sessions: 
	--------------------------------------------------------------
		In-Memory Sessions: 		Stores session data in the server’s memory(RAM).
		JDBC-Based Sessions: 		Stores session data in a relational database.
		Redis-Based Sessions: 		Stores session data in Redis, which allows for better scalability.
		Session Cookies: 			Spring Boot uses cookies by default to store the session ID on the client side.
		
		
	Steps to Implement Session Management in Spring Boot:
	-----------------------------------------------------
		1) Configure Session Management:
		--------------------------------
			configure the session settings in the application.properties file.
		
				spring.application.name=SessionManagement

				# Default session timeout (in seconds)
				server.servlet.session.timeout=600
				
				# Configure session cookie								(In-Memory based session)
				server.servlet.session.cookie.name=MY_SESSION_COOKIE
				server.servlet.session.cookie.http-only=true
				server.servlet.session.cookie.secure=true

				# Enable JDBC session 									(if using JDBC)
				# spring.session.store-type=jdbc

				# Enable Redis session 									(if using Redis)
				# spring.session.store-type=redis


				
			Here, we set the session timeout to 600 seconds. 
			The session ID is stored in a secure cookie that is HTTP-only. 
			The session storage can be switched between in-memory, JDBC, or Redis depending on your needs.

		
		2) Create the Session Controller:
		---------------------------------
			Next, we create a SessionController to handle "session creation, retrieval, and invalidation".

			SessionController.java:	
			-----------------------
				package com.app;

				import org.springframework.web.bind.annotation.GetMapping;
				import org.springframework.web.bind.annotation.RequestMapping;
				import org.springframework.web.bind.annotation.RestController;

				import jakarta.servlet.http.HttpSession;

				@RestController
				@RequestMapping("/session")
				public class SessionController {

					//1. Create a session and store an attribute
					---------------------------------------------
					@GetMapping("/create")
					public String createSession(HttpSession session) {
						session.setAttribute("username", "JohnDoe");		// Set a session attribute (e.g., username)
						String sessionId = session.getId();					// Retrieve and return the session ID
						return "Session created with ID: " + sessionId;
					}

					//2. Retrieve session attribute
					-------------------------------
					@GetMapping("/get")
					public String getSession(HttpSession session) {
						
						String username = (String) session.getAttribute("username");  //Get the session attribute(username)

						if (username == null) {								//If no session exists, return an error message
							return "No session found!";
						}

						return "Session found with username: " + username;			// Return session data to the client
					}

					//3. Invalidate the session
					---------------------------
					@GetMapping("/invalidate")
					public String invalidateSession(HttpSession session) {
						session.invalidate();										// Invalidate the session
						return "Session invalidated!";
					}
				}
				
			CreateSession:  Creates a new session and stores a username attribute. The session ID is returned to the client.
			GetSession: 		Retrieves the session and the username attribute.
			InvalidateSession: 	Invalidates the session, logging out the user.	
			
			
		3) Testing the Session Management Endpoints:
		--------------------------------------------
			Create a Session:
			-----------------
				URL: 				http://localhost:8080/session/create
				Expected Output: 	"Session created with ID: [session ID]"

			Get Session Data:
			-----------------
				URL: 				http://localhost:8080/session/get
				Expected Output: 	"Session found with username: JohnDoe" (if session exists)
	
			Invalidate a Session:
			---------------------
				URL: 				http://localhost:8080/session/invalidate
				Expected Output: 	"Session invalidated!"
				After invalidation, re-accessing the get endpoint will return "No session found!"
				
				



				
===========================================================================================================================

Session Management vs User Authentication:
------------------------------------------
	User authentication and Session management are closely related but serve distinct purposes in web security. 

	User Authentication:
	--------------------
		Purpose:
			To verify who the user is.
		
		How it works:
			User provides credentials (e.g., username and password).
			Backend checks credentials against stored data (usually hashed passwords).
			If valid, the user is authenticated.
		
		Key Points:
			Happens once per login.
			Can use methods like: passwords, biometrics, OTP, OAuth, etc.
			Often results in issuing a token or session ID.
		
		Think of authentication as the door check — proving you’re allowed in.


	Session Management:
	------------------- 	
		Purpose:
			To maintain the user's authenticated state across multiple requests.
		
		How it works:
			After authentication, the server creates a session (OR issues a token).
			The client stores a session ID (usually in a cookie) OR a token (e.g., JWT).
			With each request, the client sends this identifier.
			The server uses it to recognize the user and apply access controls.
		
		Key Points:
			Keeps users logged in.
			Can expire or be revoked.
			Must be stored and transmitted securely.
	
		Think of session management as the hall pass — letting you move around without re-authenticating.


Diff b/w JSESSIONID and Bearer token:
-------------------------------------
	Let's break down the difference between JSESSIONID and a Bearer token, as they represent two distinct approaches to managing user sessions and authentication:
	
	What is JSESSIONID?
	-------------------
		Type: 		Session Identifier
		Used In: 	Traditional server-side session management (e.g., Java EE, Spring)
		
		How It Works:
			When a user logs in, the server creates a session and stores user data in memory or a database.
			The server sends a JSESSIONID cookie to the client.
			On each request, the browser sends this cookie back.
			The server looks up the session using the ID and authenticates the user.
	
		Stateful: The server maintains session state.


	What is a Bearer Token?
	-----------------------
		Type: Access Token (often a JWT)
		Used In: Token-based authentication (e.g., OAuth 2.0, REST APIs)

		How It Works:
			After login, the server issues a token (e.g., JWT) to the client.
			The client stores it (e.g., in memory or localStorage).
			On each request, the client sends the token in the Authorization header:
		
				Authorization: Bearer <token>
		
			The server verifies the token’s signature and claims.
	
	Stateless: No session data stored on the server.
	


UI has some user session expiration time and backend apis would also have accessToken expiration time, Let's suppose if accessToken got expired but user session is still active and if user has performed some action on UI which expect to hit an api, then what happened because accesstoken has expired at the time when UI is calling this, will the call fail or what happened?
-----------
	
	Session vs Access Token:
	------------------------
		User Session:
		-------------
			User Session typically refers to a browser-level or client-side construct, sometimes maintained via cookies or localStorage. It indicates the user is still “logged in” from the UI perspective.
		
		Access Token:
		-------------	
			Access Token is usually issued by an authentication server (like OAuth or JWT) and attached to API requests to verify identity and permissions. It often has a shorter lifespan.


	Token Expired, UI Still Active—What Happens?
	--------------------------------------------
		If the access token expires but the UI session remains active, here's what typically occurs:
			The API call fails with a status code like 401 Unauthorized because the expired token is invalid.
			The backend cannot authenticate the request, so it won’t process it.
			The UI may catch the error and trigger a specific flow—like trying to refresh the token silently using a refresh token, or redirecting the user to log in again if refreshing fails.

	Handling It Gracefully:
	-----------------------
		Here’s what a robust app would do:
			On receiving a 401 Unauthorized, check if a refresh token is available.
			If yes, call a token refresh endpoint to get a new access token.
			Retry the original API call after acquiring a new access token.
			If no refresh token exists or it has also expired, gracefully prompt the user to log back in.


	Issue: Token Expired, But Still Accepted for a While:
	-----------------------------------------------------
		In this app, we had set JWT tokens to expire in 15 minutes (exp claim), but users were still able to make API calls for up to a few minutes after the expiration. It was baffling—until we dug deeper and realized:
			- The JWT filter was validating tokens against the system time.
			- But the deployment server had a time drift due to misconfigured NTP, causing it to lag behind real time by 2-3 minutes.
		
		Resolution:
			- Synced server time using NTP (ntpd service).
			- Added extra logging to token validation to compare actual versus claimed expiration timestamps.
			- Learned to never underestimate "time zone and clock sync issues" when dealing with security!



===========================================================================================================================


---------------------------	
JWT/Opaque or OAuth tokens:
---------------------------
	JWT/Opaque are token format while OAuth is a protocol.
	JWTs/Opaque are often used within OAuth as a format for access tokens. 
		
	How They Work Together:
	-----------------------
		OAuth 2.0 is a framework for 'delegated authorization'.
		
		It defines how clients get access tokens to act on behalf of users:
			You need third-party login (e.g., Google, Facebook).
			You want delegated access (e.g., app accessing user’s calendar).

		These access tokens can be:
		---------------------------
			Opaque tokens (random strings, validated via introspection).
			JWTs (self-contained, validated via signature).
	
	Example:
		Auth0, Firebase, AWS Cognito, and Azure AD all issue JWTs via OAuth flows.


Diff b/w OAuth and Auth0:
-------------------------
	Auth0 is a IAM Platform while OAuth is a protocol.

	Think of OAuth as the blueprint for secure delegated access.
	Think of Auth0 as a ready-made service that uses OAuth (and more) to handle identity and access.
	Auth0 uses OAuth under the hood, but adds a lot of value on top—like user databases, login UIs, and security features.
	
	OAuth: The Protocol:
	--------------------
		Definition: 
			OAuth 2.0 is an open standard protocol for authorization.
		
		*Purpose: 
			It allows users to grant limited access to their resources (like Google Drive or GitHub) to third-party apps without sharing their credentials.
			
		Functionality:
			Defines roles (resource owner, client, authorization server).
			Uses access tokens to authorize requests.
			Commonly used in login flows (e.g., “Login with Google”)
		

	Auth0: The Platform:
	--------------------
		Definition: 
			Auth0 is a commercial identity management platform.
		
		Purpose: 
			It provides authentication, authorization, and user management services for web and mobile apps.

		Functionality:
			Implements OAuth 2.0 (and other protocols like OpenID Connect, SAML).
			Offers features like social login, multi-factor authentication, single sign-on (SSO), and user profile management
			Provides SDKs and APIs to easily integrate authentication into your app.
			
		Bonus: Features You Can Add with Auth0:
			Passwordless login (email or SMS)
			Social login (Google, Facebook, Apple)
			Enterprise login (SAML, LDAP)
			Custom rules/hooks for advanced logic
			User management dashboard

		Tokens Returned by Auth0(OAuth 2.0 Protocol + OIDC Protocol):
		-------------------------------------------------------------
			ID Token: 					Contains user identity (name, email, etc.)
			Access Token: 				Used to access protected resources
			Refresh Token (optional): 	Used to get new access tokens without re-login	
	

OAuth used for authentication or for session:
---------------------------------------------
	OAuth: Authorization, Not Session Management
	--------------------------------------------
		OAuth 2.0 is a protocol for authorization, not authentication or session management.
		It allows third-party apps to access user resources without exposing credentials.
	
		Example: “Login with Google” uses OAuth to let your app access user info from Google.
	
		OAuth is ideal for delegated access — letting apps act on behalf of users.

	Common Misconception:
	---------------------
		Many developers mistakenly use OAuth as an authentication protocol. While it can be combined with OpenID Connect (OIDC) to support authentication, OAuth itself does not manage sessions.


Diff b/w OpenID Connect provider and OAuth 2.0 provider?
--------------------------------------------------------
	OpenID Connect and OAuth 2.0 are two diff protocols used for authentication and authorization purpose respectly.
	OICD extends OAuth 2.0 to include authentication.

	Summary:
	--------
	Feature 				OAuth 2.0 Provider 							OpenID Connect (OIDC) Provider
	-------					------------------							------------------------------
	Primary Purpose 		Authorization: Grants access to resources 	Authentication + Authorization 
	What It Proves 			What the user can do 						Who the user is + what they can do
	Tokens Issued 			Access token, refresh token 				Access token, refresh token, ID token
	Identity Verification 	Not built-in 								Built-in via ID token
	Token Contents 			May include scopes, expiry, permissions 	Includes user identity claims (e.g., email, name)
	Protocol Layer 			Base protocol 								Extension built on top of OAuth 2.0
	Use Case 				API access, delegated permissions 			Login systems, Single Sign-On (SSO), identity


	OAuth 2.0 Provider:
	-------------------
		Focuses on authorization.
		Allows apps to access user data without exposing credentials.
		Example: Letting a calendar app access your Google Calendar.
	
	OpenID Connect Provider:
	------------------------
		Extends OAuth 2.0 to include authentication.
		Issues an ID token to confirm the user's identity.
		Example: Logging into a website using your Google account.
	
	OAuth lets apps access data. OpenID Connect lets apps know who you are.
	
	
Choosing Between OAuth 2.0 and OpenID Connect:
----------------------------------------------
	
	Use OpenID Connect if:
	----------------------
		You need to authenticate users (i.e., verify their identity).
		You want to implement Single Sign-On (SSO).
		You need access to user profile information (e.g., name, email).
		You want to securely log users in using third-party identity providers (Google, Microsoft, etc.).
	
		Ideal for: Web apps, mobile apps, and APIs that require user login.

	
	Use OAuth 2.0 if:
	-----------------
		You only need to authorize access to resources (e.g., files, calendars, APIs).
		You don’t care who the user is—just what they’re allowed to do.
		You’re building a system where users grant access to their data without sharing credentials.
		
		Ideal for: Backend services, API integrations, delegated access scenarios.

	
	Combined Use Case:
	------------------
		Many modern apps use both:
			OpenID Connect for login and identity.
			OAuth 2.0 for accessing user data after login.

		For example:
			A fitness app might use OpenID Connect to log users in with Google, and OAuth 2.0 to access their Google Fit data.
			
			
			
Access Token is generated by OAuth2.0 protocol and ID Token is generated by OpenID Connect (OIDC) protocol ?
------------------------------------------------------------------------------------------------------------
	Access Token — From OAuth 2.0
	-----------------------------
		Purpose: 		Grants access to protected resources (like APIs).
		Generated By: 	The OAuth 2.0 Authorization Server.
		Contents: 		May include scopes, expiration, and permissions—but not identity.
		Used By: 		The client app to access backend services or APIs.
		Format: 		Often a JWT, but can be opaque depending on the provider.
	
		Example use: A calendar app uses an access token to fetch your events from Google Calendar.

	
	ID Token — From OpenID Connect (OIDC):
	--------------------------------------
		Purpose: 		Verifies the identity of the user.
		Generated By: 	The OIDC layer on top of OAuth 2.0.
		Contents: 		Includes user identity claims like sub (user ID), name, email, picture, etc.
		Used By: 		The client app to authenticate the user.
		Format: 		Always a JWT.
		
		Example use: A web app uses the ID token to confirm that the user is "John Doe" who just logged in via Google.

	Combined Flow: OIDC + OAuth 2.0
	-------------------------------
		When you use OpenID Connect, you get both tokens:
		
		Token Type 		Protocol 		Purpose 		Used For
		----------		--------		-------			--------
		Access Token 	OAuth 2.0 		Authorization 	Accessing APIs
		ID Token 		OpenID Connect 	Authentication 	Verifying user identity 

	Why This Matters:
	-----------------
		If you're building a login system: You need the ID Token (OIDC).
		If you're building an API gateway: You need the Access Token (OAuth 2.0).
		If you're doing both: Use OIDC on top of OAuth 2.0 to get both tokens in one flow.

	
Can we use OAuth 2.0 protocol for authentication instead of authorization:	
--------------------------------------------------------------------------
	Here's a clear breakdown of why OAuth 2.0 alone is not sufficient for authentication, and why OpenID Connect (OIDC) is necessary when you want to authenticate users securely and reliably.

	OAuth 2.0: Designed for Authorization:
	--------------------------------------
		OAuth 2.0 is fundamentally an authorization framework, not an authentication protocol.
	
		What OAuth 2.0 Does:
		--------------------
			Allows a user to delegate access to their resources (e.g., Google Drive, GitHub repos) to a third-party app.
			Issues access tokens that let the app act on behalf of the user.
			Does not define how to verify a user's identity.

		Why It’s Not Enough for Authentication:
		---------------------------------------
			OAuth 2.0 tokens are meant to grant access, not prove identity.
			The access token is an opaque string from the client’s perspective—it doesn’t say who the user is.
			There’s no standardized way to get user profile data or validate identity.
	
		Think of OAuth like a hotel key card: it lets you into a room, but doesn’t say who you are or how you got it.


	OpenID Connect (OIDC): Adds Authentication to OAuth:
	----------------------------------------------------
		OIDC is a layer built on top of OAuth 2.0 that adds identity verification.
		
		What OIDC Adds:
		---------------
			ID Tokens: 				JWTs that contain verified user identity info (e.g., name, email, user ID).
			UserInfo Endpoint: 		Lets apps fetch additional profile data.
			Standard Scopes: 		Like openid, profile, email to request identity data.
			Authentication Flows: 	Secure login flows like Authorization Code with PKCE.

		Why You Need OIDC:
		------------------
			It provides a standardized, secure way to authenticate users.
			You get verifiable identity data from a trusted provider (e.g., Google, Auth0).
			It supports Single Sign-On (SSO) and federated identity.
			It removes the need for your app to manage passwords or credentials.

		Summary Table:
		--------------
		Protocol 		Purpose 						Identity Info	Token Type 		Use Case Example 
		--------		-------							-------------	----------		----------------
		OAuth 2.0 		Authorization 					No				Access Token 	App accessing user's calendar
		OpenID Connect 	Authentication + Authorization 	Yes 			ID Token +  	App logging in user via Google
																		Access Token

		So yes, you can hack OAuth 2.0 to do authentication, but it’s not secure or standardized. That’s why OIDC is the recommended approach when you need to know who the user is.

	
	Auth0 acts as the Authorization Server in the OAuth 2.0 framework and supports OpenID Connect (OIDC) on top of OAuth 2.0 to enable authentication.


Login flow diagram for an app using Auth0 with OpenID Connect:
--------------------------------------------------------------
	
	[User] 
	   ↓ clicks "Login"
	[Your App]
	   ↓ redirects to
	[Auth0 Hosted Login Page]
	   ↓ user enters credentials / chooses social login
	[Auth0]
	   ↓ authenticates user
	   ↓ returns tokens to
	[Your App]
	   ↓ stores ID token & access token
	   ↓ uses access token to call
	[Protected APIs]



How OAuth 2.0 + OpenID Connect (OIDC) works for login and session handling:
---------------------------------------------------------------------------
	
	1. OAuth + OpenID Connect Login Flow:
	-------------------------------------
		
		[1] User clicks "Login with Provider"
				↓
		[2] Client App redirects to Authorization Server (e.g., Google/Auth0/Okta)
				↓
		[3] User authenticates (enters credentials)
				↓
		[4] Authorization Server redirects back to Client App with:
				Authorization Code
				↓
		[5] Client App sends Authorization Code to Authorization Server
				Along with Client ID & Secret
				↓
		[6] Authorization Server responds with:
				Access Token (OAuth)
				ID Token (OpenID Connect, usually a JWT)
				Optional Refresh Token
				↓
		[7] Client App stores tokens securely
				Access Token: used for API calls
				ID Token: used to identify the user
				Refresh Token: used to renew access token
				↓
		[8] Session is maintained via:
				Short-lived access token
				Refresh token rotation
				Optional HttpOnly cookie for refresh token
			  
	
	2. Step-by-Step: How Backend Verifies User Credentials:	(First authenticate user then generate JWT token)
	-------------------------------------------------------
		1. User Submits Login Form	-	Client sends a POST request to the backend.
		2. Backend Receives and Validates Input
		3. Lookup User in Database	- Query the database for the user by email or username.
		4. Compare Passwords Securely	-	If the hash matches, the user is authenticated.
		5. Generate Authentication Token - If credentials are valid and user is authenticated:
					- Generate a JWT or session ID.
					- Include user ID, roles, expiration, etc.
					- Send token back to client.
		6. Store Session or Token
					- Optionally store session in DB or memory (for server-side sessions).
					- Or send JWT to client for stateless auth.
			



	
===========================================================================================================================

===========================================================================================================================
								JWT Authentication
===========================================================================================================================
Authorization server can generate tokens in two format: JWT or Opaque token.


How JWTs Differ from Other Tokens:
---------------------------------
	Feature 				JWT 								Opaque Token
	-------					---									------------
	Readable Structure 		Yes (Base64 encoded) 				No (just a string of characters)
	Self-contained Data 	Yes 								No — server stores info
	Verification 			Cryptographically signed 			Server-side lookup
	Performance 			Fast (no DB lookup needed) 			Slower (requires storage access)
	Storage 				Often in cookies or localStorage 	Depends on implementation
	Revocation Difficulty 	Harder to revoke (stateless) 		Easier (stored centrally) 	
	

If you're building an app, the choice depends on your architecture:
-------------------------------------------------------------------
	1. JWTs: 			for stateless APIs and microservices.					(one way of token format type)
	2. Opaque tokens: 	if you want centralized control and easy revocation.	(another way of token format type)
	
	
Token verification:
-------------------
	JWT : 			Can be verified locally using public keys (no need to call the auth server.)
	Opaque token: 	The resource server must call the authorization server to validate and get details about the token.	
	
	
Diff b/w JWT, Opaque token and Session token:
---------------------------------------------
	Commonly JWT and Opaque token are used for authentication and authorization purpose while session token is used to maintain the user's state across multiple requests.
	
	
JWT Vs Session token:
---------------------	
	Criteria 				JWT 			Session Token
	--------				---				-------------
	Stateless 				Yes 			No
	Includes user info 		Yes 			No 
	Server-side storage 	Not needed 		Required
	Easy to revoke 			Not really 		Yes
	Scalability 			High 			Limited
	Expiry management 		Built-in (exp) 	Managed server-side

	Use Cases:
	----------
		JWT: 
			Great for microservices, APIs, SPAs, when you want scalability and stateless auth.
		
		Session Token: 
			Ideal for apps where quick revocation, tighter control, or centralized user state is needed.

	Note:
		Session Token cann't be stateless because it's stored on server's memory and for stateless, it needed sticky sessions or session token replication mechanism which is bit complex, still not a good option for stateless or scalability.

	


Diff b/w opaque token and session token?
----------------------------------------
	Both opaque tokens and session tokens are used in authentication and authorization systems, but they serve slightly different purposes and behave differently. 

	Opaque Token:
	-------------
		An opaque token is a token whose internal structure is not visible or meaningful to the client or resource server.
		
		Non-transparent: 
			The token is just a random string; it doesn’t carry any readable information.
		
		Requires introspection: 
			The resource server must call the authorization server to validate and get details about the token.
		
		Used in OAuth2: 
			Common in systems where the resource server and authorization server are separate.
		
		Secure by design: 
			Since it doesn’t expose any data, it reduces the risk of leaking sensitive info.
			
		Pros: Keeps token details hidden; easier to rotate or revoke.
		
		Cons: Requires extra network call for introspection.
	

		Example:	Token: 2YotnFZFEjr1zCsicMWpAA


	Session Token:
	--------------
		A session token is typically used to maintain a user's session after login, especially in traditional web applications.
		
		


Diff b/w authorization code, id token and access token ?
--------------------------------------------------------
	Differences between an authorization code, ID token, and access token—especially in the context of OAuth 2.0 and OpenID Connect:
	
		Authorization code: A temporary code issued to the client after the user successfully authenticates.
		ID Token:			Used for authentication purpose generated by OpenID Connect.	(JWT)
		Access Token: 		Used for authorization purpose generated by OAuth 2.0.			(opaque or JWT)


	1. Authorization Code:
	----------------------
		What It Is:
			A temporary code issued to the client after the user successfully authenticates.
			Used to exchange for tokens (ID token and access token).
		
		Purpose:
			Adds a layer of security by keeping tokens off the browser.
			Used in Authorization Code Flow (especially for server-side apps).
		
		Key Traits:
			Short-lived
			Cannot access resources directly
			Must be exchanged at the token endpoint
			
	
	2. ID Token:
	------------
		What It Is:
			A JWT that contains information about the authenticated user.
			Issued by the "OpenID Connect provider".
		
		Purpose:
			Used for authentication—proves who the user is.
			Contains claims like sub, email, name, iat, exp.
		
		Key Traits:
			Should not be used for accessing APIs
			Validated by the client app
			Always in JWT format
	
		“An ID token is proof that the user has been authenticated.”
		
		
	3. Access Token:
	----------------
		What It Is:
			A token (opaque or JWT) that grants access to protected resources.
			Issued by the "OAuth 2.0 provider".
		
		Purpose:
			Used for authorization—tells APIs what the user is allowed to do.
			Sent in the Authorization header when calling APIs.
		
		Key Traits:
			Should not be used for authentication
			Validated by the resource server
			Often short-lived and scoped
		
		“Access tokens must never be used for authentication.” — C# Corner


	Summary Table:
	--------------
		Token Type 			Format 					Purpose 				Used By 			Can Access APIs?
		----------			------					-------					-------				----------------	
		Authorization Code 	Short string 			Exchange for tokens 	OAuth client 		No
		ID Token 			JWT 					Authentication 			Client app 			No
		Access Token 		JWT/Opaque 				Authorization 			Resource server 	Yes


Diff b/w ID Token and Access Token:
-----------------------------------
	Real-World Analogy:
	-------------------
		ID Token 		= 	Passport (proves who you are)
		Access Token 	= 	Visa (grants permission to enter specific places

	Summary:
	--------
		Token Type 		Purpose 		Sent to API? 
		----------		-------			------------
		ID Token 		Authentication 	No
		Access Token 	Authorization 	Yes
	
	
	Summary Table:
	--------------
		Token Type 	Generated By 		Purpose 			Stored Where
		----------	------------		-------				------------
		ID Token 	Identity Provider 	Authentication 		Client (e.g., localStorage)
		Session ID 	Application Server 	Session Management 	Server + Client Cookie	
		
		
	ID Token vs Access Token:
	-------------------------
		Feature 			ID Token 										Access Token
		-------				--------										------------
		Purpose 			Authentication: proves the user’s identity 		Authorization: grants access to resources
		Contents 			User info (e.g., name, email, sub) 				Scopes, permissions, expiry
		Who Uses It 		OAuth client (e.g., your app) 					Resource server (e.g., API) 
		Format 				Always a JWT (in OpenID Connect) 				Can be JWT or opaque string
		Sent To 			Your app (after login) 							APIs (in Authorization header)
		Should Be Used For 	Displaying user info, login session 			Accessing protected endpoints
		Validated By 		Your app (using public keys) 					API server (via introspection or JWT check)
		Issued by			OpenID Connect provider							OAuth 2.0 provider


Do we need to send both id token and access token to call or access an api ?
----------------------------------------------------------------------------
	No—you do not need to send both the ID token and access token to call or access an API. You should only send the access token when making API requests.
	
	Why Not Use the ID Token?
	-------------------------
		ID tokens are for authentication, not authorization.
		They prove who the user is, but not what they’re allowed to do.
		APIs are designed to validate access tokens, not ID tokens.
	
		“You shouldn't use an ID token to call an API. Access tokens are used for authorization.”
		
	What You Should Send:
	---------------------
		When calling an API, include the access token in the Authorization header:
			
			Authorization: Bearer <access_token>

		The API will validate the access token to:
		Confirm it’s not expired
		Check scopes/permissions
		Identify the user (via sub claim or introspection)

	
Where ID Tokens Are Used:
-------------------------
	1. Client-Side Authentication:
	------------------------------
		After a user logs in via an identity provider (e.g., Google, Microsoft, Auth0), the app receives an ID token.
		The app decodes and verifies the token to confirm the user's identity.
		Common in Single Sign-On (SSO) scenarios. ID Token helps determine who the user is without needing to query the identity provider again. so we can jump in b/w apps without asking for creds again from user.
	
	2. User Interface Personalization:
	----------------------------------
		The ID token contains claims like name, email, and picture.
		These claims are used to personalize the UI (e.g., display the user’s name or avatar).
	
	3. Session Management:
	----------------------
		Web apps may use the ID token to establish a session after login.
		It helps determine who the user is without needing to query the identity provider again.
	
	4. Database Operations:
	-----------------------
		Claims like sub (subject) or email can be used as unique identifiers for users in your database.
	
	5. Security Checks:
	-------------------
		The client app validates the token’s signature, issuer (iss), audience (aud), and expiration (exp) to ensure it’s legitimate and hasn’t been tampered with.


	
Comparing opaque tokens, session tokens, and JWTs (JSON Web Tokens) in the context of OAuth 2.0 and OpenID Connect (OIDC) reveals how each fits into modern authentication and authorization systems:
---------------------------------------------------------------------------

	How They Fit into OAuth 2.0 & OpenID Connect:
	---------------------------------------------
		
		1. Opaque Tokens in OAuth 2.0:
		------------------------------
			Access Tokens: 	Often opaque in OAuth 2.0 implementations like Okta or Auth0.
			
			Usage: 			Sent to resource servers to access protected APIs.
			
			Validation: 	
				Resource server must call the authorization server’s /introspect endpoint to verify and get token metadata.
			
			Pros: Keeps token details hidden; easier to rotate or revoke.
			Cons: Requires extra network call for introspection.

		
		2. JWTs in OAuth 2.0 & OIDC:
		----------------------------
			Access Tokens or ID Tokens: JWTs are often used as access tokens or ID tokens in OpenID Connect.
			Self-contained: Encodes user info, scopes, expiration, etc., in the token itself.
			Validation: Can be verified locally using public keys (no need to call auth server).
			
			Pros:
				Fast validation.
				Useful for stateless APIs.
				Can carry rich claims.
			
			Cons:
				Harder to revoke.
				Larger token size.
				Risk of exposing sensitive info if not encrypted.



		3. Session Tokens in Traditional Web Auth:
		------------------------------------------
			Used in login-based web apps: 	After login, a session token is stored in a cookie.
			Server-side state: 				Maps to a session object with user info.
			Validation: 					Server checks its session store (e.g., Redis, DB).
			
			Pros:
				Easy to revoke.
				Secure when used with HTTP-only cookies.
			Cons:
				Doesn’t scale well across distributed systems without session replication.

		
		Summary Table:
		--------------
			Token Type 		Self-contained 	Validation Method 			Common Use Case 			Revocation Ease
			----------		--------------	-----------------			---------------				---------------
			Opaque Token 	No 				Server-side introspection 	OAuth2 APIs 				Easy
			JWT 			Yes 			Local signature check 		OAuth2/OIDC, microservices 	Hard 
			Session Token 	No 				Server-side session lookup 	Web app login sessions 		Easy 


	Real-World Usage Examples:
	--------------------------
		Auth0 / Okta: 			Let you choose between opaque tokens and JWTs for access tokens.
		Google OAuth: 			Uses JWTs for ID tokens in OpenID Connect.
		Express.js / Django: 	Use session tokens stored in cookies for user login.

	If you're building an app, the choice depends on your architecture:
		JWTs for stateless APIs and microservices.
		Opaque tokens if you want centralized control and easy revocation.
		Session tokens for traditional web apps with server-side rendering.
	

Can an ID Token Be Used Like a Session ID?
------------------------------------------
	Technically, yes—you can use an ID token to maintain a session, especially in stateless architectures like SPAs (Single Page Applications). 
	But:
		- It’s not a traditional session ID.
		- It doesn’t point to server-side session data.
		- It’s self-contained (JWT), so the app must validate it on every request or store it securely.

	Think of it like this:
		Session ID 	= key to a locker (server holds the contents)
		ID Token  	= a sealed envelope with everything inside (no locker needed)	(Token Type: JWT)

	When to Use Each:
	-----------------
		Use ID tokens in token-based auth (e.g., OAuth + OpenID Connect).
		Use session IDs in cookie-based auth (e.g., traditional web apps).

	So while you might use an ID token to maintain a session-like experience, it’s not the same as a session ID.
	
	
Who generates ID Token and who generates SessionID ?:
-----------------------------------------------------
	Who Generates the ID Token?
	---------------------------
		Generated By:
			Identity Provider (IdP) or Authorization Server
			Examples: Google, Microsoft, Auth0, Okta
		
		When:
			After a successful login via OpenID Connect
			As part of the OAuth 2.0 Authorization Code Flow (or Implicit Flow)
		
		What It Contains:
			Claims about the user (e.g., sub, email, name)
			Issuer (iss), audience (aud), expiration (exp)
			Digitally signed JWT
		
		The ID token is created and signed by the identity provider to assert the user's identity.


	Who Generates the Session ID?:
	------------------------------
		Generated By:
			Your Application Server
		
		When:
			After authenticating the user (e.g., via login form or token validation)
			When initiating a server-side session
		
		What It Contains:
			A random string (e.g., UUID or secure hash)
			Maps to session data stored on the server (e.g., user ID, login time)
		
		The server creates the session ID, stores it, and sends it to the client via a cookie. The client then includes it in future requests.


	Summary Table:
	--------------
		Token Type 	Generated By 		Purpose 			Stored Where
		----------	------------		-------				------------
		ID Token 	Identity Provider 	Authentication 		Client (e.g., localStorage)
		Session ID 	Application Server 	Session Management 	Server + Client Cookie


Can an Authorization Server Generate a Session ID?
--------------------------------------------------
	Technically, Yes—But It’s Not Typical:
	--------------------------------------
		While an authorization server (like Google, Auth0, or Microsoft Entra ID) can issue tokens (ID tokens, access tokens, refresh tokens), it does not usually generate session IDs in the traditional sense used for server-side session management.
		
		However, in custom implementations or advanced flows, the authorization server can issue a session-like token—often a JWT—that behaves like a session ID. This is especially common in Backend-for-Frontend (BFF) architectures or token-based session management.
	
		Example:
		--------
			A backend server receives an access token from the authorization server.
			It then creates its own session token (e.g., a JWT or opaque string) to manage user sessions internally.
			This session token is returned to the client and used for subsequent requests.
		
		In one real-world example using Microsoft Entra ID, the backend server generates a session token after exchanging the authorization code, and caches it along with the access token.


	Who Typically Generates Session IDs?:
	-------------------------------------
		Usually: Your Backend Server
		----------------------------
			In traditional web apps, the backend server authenticates the user and creates a session ID.
			This session ID is stored server-side and sent to the client via a secure cookie.
			It’s used to track the user’s session across requests.


	Summary:
	--------
		Generator 				Session ID Role 						Typical Use Case
		---------				---------------							----------------
		Authorization Server 	Rarely generates session-like tokens 	Advanced flows, BFF, token-based auth
		Backend Server 			Generates and manages session IDs 		Traditional web apps, cookie-based auth



	
===========================================================================================================================
-------------------
Structure of a JWT:
-------------------
	JWTs consist of three parts:	
		header.payload.signature

	Part 		Contents 							Purpose 
	----		--------							-------
	Header 		Algorithm & token type 				Tells how the token is signed
	Payload 	Claims (e.g. user ID, roles, exp) 	Holds the actual data
	Signature 	Signed using secret/key 			Verifies token integrity
	

	When to Use JWT:
	----------------
		Ideal for stateless authentication in APIs
		Common in single-page applications (SPAs)
		Great when scalability is a priority (no need to track sessions server-side)
		
	JWTs are more suitable for:
	---------------------------
		Stateless APIs (e.g., mobile apps, SPAs).
		Microservices where central session storage is impractical.
		Short-lived sessions with refresh token rotation.	

	Considerations & Risks:
	-----------------------
		Because JWTs are self-contained, once issued, they’re valid until expiry—unless you set up complex blacklisting.
		If stored in localStorage, they’re vulnerable to XSS attacks. Using HttpOnly cookies can help mitigate that.

	Best Practices:
	---------------
		Use HTTPS to prevent token interception.
		Store secrets securely (not hardcoded!).
		Rotate secrets periodically.
		Avoid putting sensitive data in the payload.
		
	
	Basic JWT Implementation Flow:
	------------------------------
		1. User Logs In:
		----------------
			User submits credentials to your login API (e.g., /api/login).
			Backend verifies them and generates a JWT containing user info (id, role, etc.).
		
		2. Backend Issues JWT:
		----------------------
			Create a token using a library (e.g., jsonwebtoken in Node.js or pyjwt in Python).
			Sign the token with a secret key.
			Send it back to the client (usually in response JSON or a cookie).
		
		3. Client Stores JWT:
		---------------------
			Store it securely:
			For web apps: HttpOnly cookie is recommended.
			For mobile: Secure storage like Keychain (iOS) or Keystore (Android).
		
		4. Client Sends JWT with API Requests:
		--------------------------------------
			Attach JWT in Authorization header:
				
			Authorization: Bearer <your-jwt-token>

		5. Backend Validates JWT:
		-------------------------
			On each protected API call, decode and verify JWT.
			Check signature, expiry (exp), and any custom claims.
			If valid, proceed. If not, respond with 401 Unauthorized.
		
		6. Token Expiry & Refresh:
		--------------------------
			Use short-lived access tokens (e.g., 15 mins).
			Provide a refresh token (longer life, stored securely).
			When access token expires, client calls a refresh endpoint to get a new one.

	
	Login Flow with JWT in Spring Boot:
	-----------------------------------
		Here’s what happens step-by-step:
	
		1. Authentication Controller (/login):
			User submits username/password.
			Spring Security or your custom service authenticates the user.
			If valid, generate JWT using a utility class and return it in the response (or set it in an HttpOnly cookie).

	
		2. Token Refresh Endpoint:
			Store a refresh token securely and associate it with the user.
			On calling /refresh-token, validate the refresh token and issue a new access token.

			You can use an in-memory store, database, or JWT itself to manage refresh tokens, depending on your architecture’s needs.

		3. Securing APIs:
			Use a filter to intercept API calls and validate JWTs.
			Register this filter in your SecurityConfig.	
		
		
	How backend generates a JWT in java?
	------------------------------------
		Let's walk through how it's done using a popular library called Java JWT (jjwt) or auth0's java-jwt

		1) Generate JWT Using jjwt (Java JWT by io.jsonwebtoken):
		---------------------------------------------------------
			import io.jsonwebtoken.Jwts;
			import io.jsonwebtoken.SignatureAlgorithm;
			import io.jsonwebtoken.security.Keys;

			import java.security.Key;
			import java.util.Date;

			public class TokenGenerator {

				private static final Key key = Keys.secretKeyFor(SignatureAlgorithm.HS256);

				public static String generateToken(String username) {
					long expirationTime = 1000 * 60 * 15; // 15 minutes

					return Jwts.builder()
							.setSubject(username)
							.setIssuedAt(new Date())
							.setExpiration(new Date(System.currentTimeMillis() + expirationTime))
							.signWith(key)
							.compact();
				}
			}


		Validation on Backend:
		----------------------
		When receiving a JWT in a request, you’ll want to verify the signature and check claims like expiration:

			Jwts.parserBuilder()
				.setSigningKey(key)
				.build()
				.parseClaimsJws(token);



	2. Generate JWT Using Auth0’s java-jwt Library:
	-----------------------------------------------
		Algorithm algorithm = Algorithm.HMAC256("secret");

			String token = JWT.create()
				.withSubject("user123")
				.withIssuedAt(new Date())
				.withExpiresAt(new Date(System.currentTimeMillis() + 15 * 60 * 1000))
				.sign(algorithm);


Step-by-Step: JWT Authentication in Spring Boot:
------------------------------------------------
	1. Add Dependencies:
	--------------------
		In your pom.xml:
		<dependency>
			<groupId>io.jsonwebtoken</groupId>
			<artifactId>jjwt-api</artifactId>
			<version>0.11.5</version>
		</dependency>
		<dependency>
			<groupId>io.jsonwebtoken</groupId>
			<artifactId>jjwt-impl</artifactId>
			<version>0.11.5</version>
			<scope>runtime</scope>
		</dependency>
		<dependency>
			<groupId>io.jsonwebtoken</groupId>
			<artifactId>jjwt-jackson</artifactId>
			<version>0.11.5</version>
			<scope>runtime</scope>
		</dependency>


	2. Create JWT Utility Class:
	----------------------------
		@Component
		public class JwtUtil {

			private final String SECRET_KEY = "your_secret_key";

			public String generateToken(String username) {
				return Jwts.builder()
						.setSubject(username)
						.setIssuedAt(new Date())
						.setExpiration(new Date(System.currentTimeMillis() + 1000 * 60 * 60)) // 1 hour
						.signWith(SignatureAlgorithm.HS256, SECRET_KEY)
						.compact();
			}

			public String extractUsername(String token) {
				return Jwts.parser()
						.setSigningKey(SECRET_KEY)
						.parseClaimsJws(token)
						.getBody()
						.getSubject();
			}

			public boolean validateToken(String token) {
				try {
					Jwts.parser().setSigningKey(SECRET_KEY).parseClaimsJws(token);
					return true;
				} catch (Exception e) {
					return false;
				}
			}
		}


	3. Create Login Endpoint:
	-------------------------
		@RestController
		@RequestMapping("/auth")
		public class AuthController {

			@Autowired
			private JwtUtil jwtUtil;

			@PostMapping("/login")
			public ResponseEntity<?> login(@RequestParam String username) {
				// Normally you'd validate credentials here
				String token = jwtUtil.generateToken(username);
				return ResponseEntity.ok(Collections.singletonMap("token", token));
			}
		}


	4. Secure Endpoints with JWT Filter:
	------------------------------------
		Create a filter to intercept requests and validate JWT:
		
		@Component
		public class JwtFilter extends OncePerRequestFilter {

			@Autowired
			private JwtUtil jwtUtil;

			@Override
			protected void doFilterInternal(HttpServletRequest request,
											HttpServletResponse response,
											FilterChain filterChain)
					throws ServletException, IOException {

				String authHeader = request.getHeader("Authorization");

				if (authHeader != null && authHeader.startsWith("Bearer ")) {
					String token = authHeader.substring(7);
					if (jwtUtil.validateToken(token)) {
						String username = jwtUtil.extractUsername(token);
						// You can set authentication context here if needed
					}
				}

				filterChain.doFilter(request, response);
			}
		}

		Register the filter in your security config.

	5. Send Token in Requests:
	--------------------------
		Use Postman or frontend to send:
		Authorization: Bearer <your_token>



Why JWT does not need to store server side?
-------------------------------------------
	The magic of JWT (JSON Web Token) lies in its self-contained nature. 
	Here’s why storing it server-side isn’t necessary for authentication.
	
	1. All User Data Is Embedded Inside:
	------------------------------------
		JWTs carry all the relevant claims (like user ID, roles, expiration time) directly in the token payload. So when the server receives a JWT:
			It just decodes the token
			Verifies the signature
			And reads the claims — no need to look anything up in a session store or database

	
	2. Stateless Authentication:
	----------------------------
		Because JWTs are signed and include expiry information, the server doesn’t need to track which tokens are valid:
			If the signature is valid and the token hasn’t expired, it’s good to go.
			If not, the server rejects it.
		
		That’s why JWTs work beautifully across distributed systems—no centralized store needed to verify sessions.
	
	3. Cryptographic Signature = Integrity:
	---------------------------------------
		JWTs are 'signed' using a secret key or public/private key pair:
			This ensures the token hasn’t been tampered with
			The server can trust the data inside, assuming the signature checks out

	
When Might You Store JWTs Server-Side?
--------------------------------------
	Technically you don’t have to, but you might choose to if:
		You want to manually revoke tokens (e.g., blacklist stolen ones)
		You’re using refresh tokens, which are typically stored server-side to control access lifecycle more tightly
		You need audit logging or session history.



How can we store JWT token securely at client side except using HttpOnly Cookie?
--------------------------------------------------------------------------------
	Alternatives to HttpOnly Cookies for Storing JWTs:
	
	1. Browser Storage:
	-------------------
		LocalStorage:
		-------------
			Easy to use and persists across sessions.
			Risk: Vulnerable to XSS attacks.

		SessionStorage:
		---------------
			Cleared when the tab is closed.
			Slightly safer than localStorage, but still vulnerable to XSS.
	
	
	2. In-Memory Storage:
	---------------------
		Store the token in a JavaScript variable during runtime.
		
		Pros: Not accessible to XSS unless the attacker can execute code during that session.
		Cons: Token is lost on page reload or tab close.
	
		Best for single-page apps (SPAs) where you can refresh tokens via silent authentication.

	3. Encrypted Storage:
	---------------------
		Encrypt the JWT before storing it in localStorage or IndexedDB.
		Use a secure key management strategy (e.g., derived from user credentials or stored in secure enclave).

		Pros: Adds a layer of protection.
		Cons: Still vulnerable if encryption keys are exposed via XSS.


	Recommended Hybrid Approach:
	----------------------------
		For SPAs:
			Store 'access token' in memory.
			Store 'refresh token' in HttpOnly cookie.
			Use silent refresh to get new access tokens.


JWT token should generate by backend server or through some authentication server?
----------------------------------------------------------------------------------
	The generation of JWTs should always be handled by a trusted backend or authentication server—never by the client. Here's why and how it works:
	
	Backend Server or Authentication Server:
	----------------------------------------
		Why?
			JWTs contain sensitive claims (like user ID, roles, permissions).
			They must be signed with a secret or private key—which should never be exposed to the client.
			The server can validate credentials (e.g., username/password, OAuth tokens) before issuing a JWT.
	
		Common setups:
			Custom backend: Your own API validates credentials and issues JWTs.
			Auth providers: Services like Auth0, Firebase Auth, AWS Cognito, or Azure AD handle authentication and JWT issuance.

	Why Not the Client?
	-------------------
		The client is inherently untrusted—anyone can inspect or manipulate it.


	Typical Flow for JWT Authentication:
	------------------------------------
		1. User logs in (e.g., via form or OAuth provider).
		2. Client sends credentials to backend or auth server.
		3. Server validates credentials.
		4. Server generates JWT with appropriate claims and signs it.
		5. JWT is sent back to client (via response body or cookie).
		6. Client stores JWT securely and uses it for authenticated requests.

	Bonus Tip: Use Refresh Tokens:
	------------------------------
		Access tokens (JWTs) should be short-lived.
		Use a refresh token (stored securely, ideally in an HttpOnly cookie) to get new access tokens without re-authenticating.


Let’s Design a Token Refresh Flow:
----------------------------------
	Here’s a classic approach many apps use (like those based on OAuth2 or JWT):

	1. Track Token Expiry:
	----------------------
		Access tokens usually come with an expiry timestamp (exp) or a TTL.
		Store this along with the token when issued so your frontend can proactively check expiry.

	2. Use a Refresh Token:
	-----------------------
		When the access token expires, send the refresh token to the auth server.
		The server validates it and issues a new access token (and optionally a new refresh token).

	3. Retry Mechanism:
	-------------------
		On any 401 response from an API, pause the request flow.
		Attempt the refresh call.
		If successful, retry the original request with the new token.
		If refresh fails, redirect the user to re-authenticate.

	4. Secure Storage:
	------------------
		Store access and refresh tokens securely—e.g., in HttpOnly cookies for protection from XSS.
		Avoid exposing them directly to JavaScript when possible.

	5. Concurrency Control:
	-----------------------
		Use flags to avoid racing multiple refresh attempts when multiple APIs fail simultaneously.

	6.  Short-Lived Access Tokens with Server-side Refresh:
	-------------------------------------------------------
		Only the backend has the refresh token; frontend talks to backend, which handles token refresh internally.
		Keeps tokens out of the browser, improving security.
		Especially useful for mobile apps or public clients.

	7. Session Token Plus API Token:
	--------------------------------
		Use a secure session token (e.g., cookie-based) for maintaining UI state.
		Separately manage API access tokens for API calls.
		UI can continue functioning while the token is refreshed or rotated in the background.
	
	8. Sliding Sessions (Rolling Expiry):
	-------------------------------------
		Extend the access token’s expiry each time the user makes an API call or interacts with the app.

	9. Silent Authentication via Hidden Iframe (OAuth2 PKCE Flow):
	--------------------------------------------------------------
		Use a hidden iframe to silently re-authenticate the user with the auth provider using a stored session/cookie.
		No refresh token needed—just leverage the session on the auth server to get a new token.
		Common in single-page apps (SPAs) using services like Auth0, Azure AD, etc.

	Bonus Tip: Rotate Refresh Tokens:
	---------------------------------
		Use refresh tokens that expire or are one-time-use.
		Issue a new refresh token each time a new access token is granted.


Refresh Token Rotation:
-----------------------
	Rather than storing one static refresh token, rotate them each time you issue a new access token.
 
	1. On Login:
	------------
		Issue access token + refresh token.
		Store refresh token in a DB or Redis, linked to the user.
	
	2. On /refresh-token:
	---------------------
		Validate old refresh token.
		Generate new access + refresh tokens.
		Invalidate old refresh token in DB/Redis.
		- Save new one.
	
	This prevents replay attacks and lets you revoke tokens easily 


Why Token Revocation Matters:
-----------------------------
	Prevents unauthorized access if a token is compromised.
	Supports logout functionality.
	Ensures compliance with security standards and regulations.

	Common Token Revocation Strategies:
	-----------------------------------
		1. Blacklist (Deny List):
		-------------------------
			- Maintain a list of revoked tokens in a database or cache (e.g., Redis).
			- Every incoming request checks if the token is on the blacklist.
			- Ideal for short-lived tokens or high-security apps.

		2. Short Expiry + Refresh Tokens:
		---------------------------------
			- Use short-lived access tokens (e.g., 15 mins).
			- Pair with long-lived refresh tokens stored securely.
			- Revoke refresh tokens to prevent new access tokens from being issued.
		
			Revocation Point: Invalidate the refresh token in the database.

		3. Token Introspection (OAuth 2.0):
		-----------------------------------
			- Use a central authorization server to validate tokens dynamically.
			- Tokens are checked against a revocation endpoint.

		4. User-Initiated Revocation:
		-----------------------------
			- Allow users to log out or revoke tokens manually.
	
		5. Rotating Secrets:
		--------------------
			- Periodically change the signing key used for JWTs.
			- All previously issued tokens become invalid.
			- Requires coordinated key rotation across services.


JWT used for authentication purpose or for session management:
--------------------------------------------------------------
	JWTs can be used for both authentication and session management.
	

Why JWTs Are Not Ideal for Session Management:
----------------------------------------------
	1. Hard to Revoke:
	------------------
		Once a JWT is issued, it's valid until it expires.
		There's no built-in way to invalidate a token early unless you:
		Maintain a blacklist on the server (which defeats the purpose of being stateless).
		Use short-lived tokens, which can frustrate users if not paired with refresh tokens.
	
	2. No Server-Side Control:
	--------------------------
		Traditional sessions store session data on the server (e.g., in Redis or memory).
		With JWTs, the server trusts the token blindly unless it tracks sessions manually.
		You can't easily log out a user or detect token theft without extra infrastructure.
	
	3. Token Bloat:
	---------------
		JWTs often include user data and claims.
		This makes them larger than simple session IDs.
		Every request carries this payload, which can impact performance—especially on mobile or low-bandwidth networks.
	
	4. Security Risks:
	------------------
		If stored in localStorage or sessionStorage, JWTs are vulnerable to XSS attacks.
		If stored in cookies without proper flags (HttpOnly, Secure, SameSite), they’re vulnerable to CSRF.
	
	5. Clock Synchronization Issues:
	--------------------------------
		JWTs rely on expiration timestamps (exp claim).
		If client and server clocks are out of sync, tokens may be rejected prematurely or accepted too long.

===========================================================================================================================
	
















	




		