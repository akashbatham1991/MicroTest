https://spring.io/blog/2011/04/26/advanced-spring-data-jpa-specifications-and-querydsl
https://docs.spring.io/spring-data/jpa/reference/jpa/specifications.html
https://spring.io/blog/2011/02/10/getting-started-with-spring-data-jpa


Reason why we need Specification:
---------------------------------
	A typical repository interface looks something like this:
	
		public interface CustomerRepository extends JpaRepoitory<Customer, Long> {
		
			Customer findByEmailAddress(String emailAddress);
		
			List<Customer> findByLastname(String lastname, Sort sort);

			Page<Customer> findByFirstname(String firstname, Pageable pageable);
		}

	The first method simply expects to find a single customer with a given email address. 
	The second method returns all customers with a given lastname and applies the given Sort to the result. 
	The third method returns a Page of customers.

	
	Although this approach is really convenient, you don't even have to write a single line of implementation code to get the queries executed. 
	
	it has two drawbacks: 
	---------------------
		first, the number of query methods might grow for larger applications.
		second, the queries define a fixed set of criterias. 
		
	To avoid these two drawbacks: 
	-----------------------------
		wouldn't it be cool if you could come up with a set of atomic "predicates" that you could combine dynamically to build your query?
	
	
	that's what the Criteria API is for? Right, so let's have a look what a sample business requirement implementation could look like using the JPA Criteria API. 
	
	Here's the use case: on their birthday's we want to send a voucher to all long term customers. 
	How do we retrieve the ones that match?
	
	We pretty much have two parts to the predicate: the birthday as well as what we call long-term-customer. 
	Here's how it would look like implemented using the JPA 2.0 Criteria API:
		
		LocalDate today = new LocalDate();
		
		CriteriaBuilder builder = em.getCriteriaBuilder();
		CriteriaQuery<Customer> query = builder.createQuery(Customer.class);
		Root<Customer> root = query.from(Customer.class);

		Predicate hasBirthday = builder.equal(root.get(Customer_.birthday), today);
		Predicate isLongTermCustomer = builder.lessThan(root.get(Customer_.createdAt), today.minusYears(2); 
		
		query.where(builder.and(hasBirthday, isLongTermCustomer));
		em.createQuery(query.select(root)).getResultList();


	What do we have here? 
	---------------------
		We create a new LocalDate for convenience and go on with three lines of boilerplate code to set up the necessary JPA infrastructure instances. 
		Then we have two lines building the predicates, one to concatenate both and a last one to execute the actual query. We're using the meta-model classes introduced with JPA 2.0 and generated by the Annotation Processing API.
	
	The main problem with this code is that:
	----------------------------------------
		the predicates are not easy to externalize and reuse because you need to set up the CriteriaBuilder, CriteriaQuery and Root first. 
		Also, readability of the code is poor as it is hard to quickly infer the intent of the code upon first glance.



Specifications:
---------------
	To be able to define "reusable Predicates" we introduced the Specification interface.
	
	Basic Concepts of JPA Specifications:
	-------------------------------------
		Specification Interface: 
			At its core, the Specification is a simple interface with a single method, "toPredicate", which converts your specification to a JPA Predicate.
			
			The Specification interface is defined as follows:

				public interface Specification<T> {
				
				  Predicate toPredicate(Root<T> root, CriteriaQuery<?> query, CriteriaBuilder builder);
				}
		
		Root, CriteriaQuery, and CriteriaBuilder: 
			These are part of the JPA Criteria API. 
			The Root is a query root from which you start the query, 
			CriteriaQuery is used to construct the query itself, and 
			CriteriaBuilder is used to define criteria and create predicates.

	1.
	To support specifications, you can extend your repository interface with the JpaSpecificationExecutor interface, as follows:

		public interface CustomerRepository extends CrudRepository<Customer, Long>, JpaSpecificationExecutor<Customer> {
		}

	2.
	The additional interface has methods that let you run specifications in a variety of ways. 
	For example, the findAll method returns all entities that match the specification, as shown in the following example:

		List<T> findAll(Specification<T> spec);
			
	3.
	Specifications can easily be used to build an extensible set of predicates as shown in the following example:	
		
		Example 1. Specifications for a Customer:
		----------------------------------------
			public class CustomerSpecs {

			  public static Specification<Customer> isLongTermCustomer() {
				return (root, query, builder) -> {
				  LocalDate date = LocalDate.now().minusYears(2);
				  return builder.lessThan(root.get(Customer_.createdAt), date);
				};
			  }

			  public static Specification<Customer> hasSalesOfMoreThan(MonetaryAmount value) {
				return (root, query, builder) -> {
				  // build query here
				};
			  }
			}
			
			
	5.
	Client might use a Specification as follows:

		List<Customer> customers = customerRepository.findAll(isLongTermCustomer());	
		
		
	6.
	The power of specifications really shines when you combine(and, or) them to create new Specification objects:
		
		MonetaryAmount amount = new MonetaryAmount(200.0, Currencies.DOLLAR);
		List<Customer> customers = customerRepository.findAll(isLongTermCustomer().or(hasSalesOfMoreThan(amount)));
			or
		customerRepository.findAll(where(customerHasBirthday()).and(isLongTermCustomer()));
	
	7.
	And with JPA 2.1, the CriteriaBuilder API introduced CriteriaDelete. This is provided through JpaSpecificationExecutor’s `delete(Specification) API.
	
		Specification<User> ageLessThan18 = (root, query, cb) -> cb.lessThan(root.get("age").as(Integer.class), 18);
		userRepository.delete(ageLessThan18);
		
		//The Specification builds up a criteria where the age field (cast as an integer) is less than 18. Passed on to the userRepository, it will use JPA’s CriteriaDelete feature to generate the right DELETE operation. It then returns the number of entities deleted.
		
		
	This reads fluently, improving readability as well as providing additional flexibility as compared to the use of the JPA Criteria API alone. The only caveat with Specification is that coming up with, the Specification implementation requires quite some coding effort.		
		
		
https://spring.io/blog/2011/04/26/advanced-spring-data-jpa-specifications-and-querydsl		
Querydsl:
---------
	To cure that pain an open-source project called Querydsl has come up with a quite similar but also different approach.

	 Just like the JPA Criteria API it uses a Java 6 annotation processor to generate meta-model objects but produces a much more approachable API. Another cool thing about the project is that it has not only has support for JPA but also allows querying Hibernate, JDO, Lucene, JDBC and even plain collections.

	So to get that up and running you add Querydsl to your pom.xml and configure the APT plugin accordingly.

	<plugin>
	  <groupId>com.mysema.maven</groupId>
	  <artifactId>maven-apt-plugin</artifactId>
	  <version>1.0</version>
	  <executions>
		<execution>
		  <phase>generate-sources</phase>
		  <goals>
			<goal>process</goal>
		  </goals>
		  <configuration>
			<outputDirectory>target/generated-sources</outputDirectory>
			<processor>com.mysema.query.apt.jpa.JPAAnnotationProcessor</processor>
		  </configuration>
		</execution>
	  </executions>
	</plugin>
	
	This will cause your build to create special query classes - QCustomer inside the very same package in our case.
	
	To execute Querydsl predicates: 
	-------------------------------	
		you simply let your repository extend QueryDslPredicateExecutor:

			public interface CustomerRepository extends JpaRepository<Customer>, QueryDslPredicateExecutor {
			  // Your query methods here
			}

	Clients can then simply do:
		QCustomer customer = QCustomer.customer;
		LocalDate today = new LocalDate();
		BooleanExpression customerHasBirthday = customer.birthday.eq(today);
		BooleanExpression isLongTermCustomer = customer.createdAt.lt(today.minusYears(2));
		customerRepository.findAll(customerHasBirthday.and(isLongTermCustomer));
		
	This is not only almost fluent English out of the box, the BooleanExpressions are even reusable without further wrapping which lets us get rid off the additional (and a bit ugly to implement) Specification wrapper.
	
	
Summary:
-------
	Spring Data JPA repository abstraction allows executing predicates either via JPA Criteria API predicates wrapped into a Specification object or via Querydsl predicates. To enable this functionality you simply let your repository extend JpaSpecificationExecutor or QueryDslPredicateExecutor (you could even use both side by side if you liked). Note that you need the Querydsl JARs in the class in case you decide for the Querydsl approach.		
	
	
------------------------------------------------------------------	
Advance:
--------
	Joins with Specifications
	Projections with Specifications
	Caching with Specifications
	
	
	Joins with Specifications:
	--------------------------
		Often, your entities will have relationships with others. For instance, a User might have many Orders. Specifications can handle this through joins. Here's how you can create a Specification to find users with a certain number of orders:

		public static Specification<User> hasMinimumOrders(int minOrders) {
			return (root, query, criteriaBuilder) -> {
				Join<User, Order> orders = root.join("orders");
				query.groupBy(root.get("id"));
				query.having(criteriaBuilder.greaterThanOrEqualTo(criteriaBuilder.count(orders), minOrders));
				return query.getRestriction();
			};
		}	
		
		
	Projections with Specifications:
	--------------------------------
		Projections allow you to fetch only the data you need, rather than retrieving entire entities. This can significantly reduce memory usage and improve query performance. Spring Data JPA supports dynamic projections, and you can use them with Specifications. Here’s an example of how you might define and use a projection:

			public interface UserNameAndStatus {
				String getName();
				String getStatus();
			}

			// In your service or controller
			List<UserNameAndStatus> users = userRepository.findAll(spec, UserNameAndStatus.class);

		This approach retrieves only the name and status of the users, which can be more efficient than fetching entire User entities.	
				
				
	Caching with Specifications:
	----------------------------
		Performance is crucial, and caching is one of the most effective ways to improve it. Spring’s caching abstraction can be used alongside Specifications. You can annotate your repository methods with @Cacheable, and Spring will handle the caching for you. Remember, caching is most effective for read-heavy operations with relatively stable data.			
		
----------------------------------------------------------------

Need of Hibernate, Criteria API, Specification and Querydsl:
-------------------------------------------------------------
	Hibernate:
	----------
		The obvious drawbacks of this approach are: 
			the lack of type safety and 
			the absence of static query checking.

		Also, in more complex cases (for instance, when the query needs to be constructed at runtime depending on some conditions), building an HQL query typically involves the concatenation of strings which is usually very unsafe and error-prone.


	Typical Repository Interface: (JpaRepository)
	-----------------------------
	Query derivation mechanism:
	--------------------------
		It has two drawbacks: 
			first, the number of query methods might grow for larger applications because of - and that's 
			the second point - the queries define a fixed set of criterias. 

	Criteria API:
	-------------
		To avoid these two drawbacks, wouldn't it be cool if you could come up with a set of atomic predicates that you could combine dynamically to build your query?

		The main problem with this code is: 
			that the predicates are not easy to externalize and reuse 
				because you need to set up the CriteriaBuilder, CriteriaQuery and Root first. Also, readability of the code is poor as it is hard to quickly infer the intent of the code upon first glance.

	Specification: (JpaSpecificationExecutor)
	--------------
		To be able to define "reusable Predicates" we introduced the Specification interface.

		The basic repository implementation will prepare the CriteriaQuery, Root and CriteriaBuilder for you, apply the Predicate created by the given Specification and execute the query. 

		This reads fluently, improving readability as well as providing additional flexibility as compared to the use of the JPA Criteria API alone. 

		The only caveat here is that coming up with the Specification implementation:
			requires quite some coding effort. 


	Querydsl: (QueryDslPredicateExecutor)
	--------- 
		To cure that pain an open-source project called Querydsl has come up with a quite similar but also different approach. 
		Consequently, querydsl gets transforms into JPQL!
		It creates "Q-type" classes that is used instead of entities. 
		The querydsl package contains a special data type called Tuple.
		One of the strengths of querydsl is that it excels when building dynamic queries. 
		There are 2 ways: Using BooleanBuilder or the Where Clause.
		By combining Querydsl’s Q-type classes with appropriate result handling methods and employing the Where Clause for dynamic queries, developers can achieve a more efficient and maintainable codebase.


	Summary:
	--------
		Spring Data JPA repository abstraction allows executing predicates either: 
			via JPA Criteria API predicates wrapped into a Specification object or 
			via Querydsl predicates. 
			
		To enable this functionality you simply let your repository extend JpaSpecificationExecutor or QueryDslPredicateExecutor 


->
there are some shortcomings in standard repository methods, 
	to overcome that, CriteriaAPI comes into picture, 
		then there are some shortcomings in CriteriaAPI, 
			to overcome that, Specification comes into picture, 
				then there are some shortcomings in Specification, 
					to overcome that, Querydsl comes into picture. 


-> 
JpaRepository
	PagingAndSortingRepository
		CrudRepository
			Repository

JpaSpecificationExecutor

QueryDslPredicateExecutor 



-> 
<dependency>
<groupId>org.springframework.boot</groupId>
<artifactId>spring-boot-starter-data-jpa</artifactId>
</dependency>


<dependency> 
<groupId>com.querydsl</groupId> 
<artifactId>querydsl-jpa</artifactId> 
<version>4.2.2</version> 
</dependency>


Diff b/w CrudRepository and JpaRepository:
------------------------------------------

	CrudRepository 																JpaRepository 
----------------------------------------------------	---------------------------------------------------------------
It contains methods for CRUD operations. 				It contains the full API of CrudRepository and
For example save(), saveAll(), findById(), 				PagingAndSortingRepository.
findAll(), etc. 										For example, it contains flush(), saveAndFlush(), etc along with 
														the methods that are available in CrudRepository.

It doesn't provide methods for implementing 			It provides all the methods for which are useful
pagination and sorting.									for implementing pagination.

To perform CRUD operations, define repository 			To perform CRUD as well as batch operations, define repository 
extending CrudRepository.								extends JpaRepository.
														
														

	

-------------------------------------------------------------------------------------------

Criteria vs JPQL vs HQL Query:
------------------------------
	Before we dive in, we should note that the Hibernate Criteria API has been deprecated since Hibernate 5.2. 
	Therefore, we’ll be using the JPA Criteria API, as it’s the new and preferred tool for writing Criteria queries. 
	
	
	Criteria Queries:
	-----------------
		The Criteria API helps in building the Criteria query object by applying different filters and logical conditions on top of it. 
		As per the user’s conditions, CriteriaBuilder controls the query results. It uses the where() method from CriteriaQuery, which provides CriteriaBuilder expressions.
		
	
	JPQL:
	-----
		JPQL stands for Java Persistence Query Language. 
		
		Spring Data provides multiple ways to create and execute a query, and JPQL is one of these. 
		
		It defines queries using the @Query annotation in Spring to execute both JPQL and native SQL queries. The query definition uses JPQL by default.

		We use the @Query annotation to define a SQL query in Spring. Any query defined by the @Query annotation has higher priority over named queries, which are annotated with @NamedQuery.	
	
		Let’s build a dynamic query using JPQL:
		---------------------------------------
			
		Using JPQL Queries:
		-------------------	
			@Query(value = "SELECT e FROM Employee e")
			List<Employee> findAllEmployees(Sort sort);
			
			@Query("SELECT e FROM Employee e WHERE e.salary = ?1")
			Employee findAllEmployeesWithSalary(Long salary);
			
			@Query("SELECT e FROM Employee e WHERE e.name = ?1 and e.salary = ?2")
			Employee findEmployeeByNameAndSalary(String name, Long salary);
			
			
		Using the JPQL Native Queries:
		------------------------------
			
		//Using indexed parameter:	
		--------------------------
			@Query(value = "SELECT * FROM Employee e WHERE e.salary = ?1", nativeQuery = true)
			Employee findEmployeeBySalaryNative(Long salary);
	
		//Using Named Parameters:
		-------------------------	
			@Query("SELECT e FROM Employee e WHERE e.name = :name and e.salary = :salary")
			Employee findEmployeeByNameAndSalaryNamedParameters(@Param("name") String name, @Param("salary") Long salary);
			
			@Query(value = "SELECT * FROM Employee e WHERE e.name = :name and e.salary = :salary", nativeQuery = true) 
			Employee findUserByNameAndSalaryNamedParamsNative(@Param("name") String name, @Param("salary") Long salary);	
			
			
	Advantages of Criteria Queries Over HQL and JPQL Queries:
	--------------------------------------------------------
		The main advantage of Criteria Queries over HQL is the nice, clean, object-oriented API. As a result, we can detect errors in Criteria API during the compile time.

		In addition, JPQL queries and Criteria queries have the same performance and efficiency.

		Criteria queries are more flexible and provide better support for writing dynamic queries as compared to HQL and JPQL.

		But HQL and JPQL provide native query support that isn’t possible with the Criteria queries. This is one of the disadvantages of the Criteria query.

		We can easily write complex joins using JPQL native queries, whereas it gets difficult to manage while applying the same with Criteria API.
		
		
		