Event-Driven Architecture (EDA):
--------------------------------
	Event-Driven Architecture (EDA) is a software design pattern in which the flow of the program is determined by events—such as user actions, sensor outputs, or messages from other programs or threads.
	
	Event Sourcing is a software design pattern in which state changes of an application are stored as a sequence of events, rather than storing just the current state.
	
	Instead of updating a database record directly, every change (event) is recorded in an append-only log. The current state is then reconstructed by replaying these events.
	

Example:
--------
	Let’s say you have a bank account:

	1. Events:
	----------
		AccountCreated
		MoneyDeposited(₹500)
		MoneyWithdrawn(₹200)
	
	2. Current Balance:
	-------------------
		Calculated by replaying: ₹0 → ₹500 → ₹300	
		

		
Key Components:
---------------
	
	1. Events:
	----------
		These are the core units of information exchanged in an event-driven architecture. 
		Events represent state changes within the system, such as user actions, updates to data, or system alerts.

	2. Event Producers:
	-------------------
		Components or services responsible for generating and emitting events. 
		They encapsulate the logic that detects and triggers events based on specific conditions or actions within the system.
	
	3. Event Consumers:
	-------------------
		Components or services that subscribe to and process events emitted by producers. 
		Consumers react to events by executing predefined actions, such as updating data stores, triggering workflows, or sending notifications.
	
	4. Event Brokers or Message Brokers:
	------------------------------------
		Middleware components that act as intermediaries between producers and consumers. 
		They manage the routing, delivery, and persistence of events, ensuring reliable communication even when producers and consumers operate at different speeds or scales.
	
	5. Event Schema and Contracts:
	------------------------------
		Defined structures or schemas that describe the format and content of events exchanged between components. Establishing clear event schemas ensures consistency and interoperability across different parts of the system.
	
	6. Subscriptions and Topics:
	----------------------------
		Mechanisms used to manage the relationship between event producers and consumers. 
		Subscriptions define which events a consumer is interested in receiving, while 
		topics categorize events based on their type or source, facilitating efficient event routing and filtering.
	
	7. Error Handling and Retry Mechanisms:
	---------------------------------------
		Strategies implemented to handle failures or disruptions in event processing. 
		This includes mechanisms for retrying event delivery, handling duplicate events, and managing exceptions that may occur during event consumption.	
	
Design Patterns for Event-Driven APIs:
--------------------------------------
	1. Publish-Subscribe
	2. Event Sourcing
	3. CQRS (Command Query Responsibility Segregation)
	4. Saga Pattern
	5. Event-Driven Choreography
	6. Event Collaboration
	7. Event Versioning
	8. Event Mesh
	9. Event-Driven Microservices
	
	1. Publish-Subscribe: 
	---------------------
		This pattern involves producers (publishers) broadcasting events to multiple consumers (subscribers) interested in those events. 
		Implementations often use a message broker to manage subscriptions and event delivery.
		
		** It promotes loose coupling, as publishers and subscribers are unaware of each other's existence. 
		
	
	2. Event Sourcing: 
	------------------
		In this pattern, the state of an application is determined by events that have occurred. 
		Instead of storing current state, applications store a sequence of events that can be replayed to rebuild state. 
		
		** This pattern is valuable for auditing, versioning, and rebuilding application state.
	
	
	3. CQRS (Command Query Responsibility Segregation): 
	---------------------------------------------------
		CQRS separates read and write operations into distinct services. 
		Write operations, commands trigger events that update state, while read operations (queries) retrieve data from optimized read models. 
		
		** This pattern enhances scalability and performance by tailoring data models to specific use cases.
	
	
	4. Saga Pattern: 
	----------------
		Useful for managing long-lived transactions across multiple services, the Saga pattern orchestrates a sequence of local transactions, each triggered by an event. 
		If a transaction fails, compensating actions (reverse transactions) are executed to maintain consistency.
		
		** The Saga pattern is best used when managing long-lived, distributed transactions across multiple microservices where data consistency needs to be maintained despite potential failures.
		
	
	5. Event-Driven Choreography: 
	-----------------------------
		In contrast to centralized orchestration, choreography allows services to communicate and collaborate through events directly. 
		Each service reacts to events it receives, coordinating actions across the system without a central controller.
	
	
	6. Event Collaboration: 
	-----------------------
		This pattern emphasizes collaboration among services through shared events. 
		Services emit events that other services might use to enrich their own behavior or data, fostering modularity and flexibility.
	
	
	7. Event Versioning: 
	--------------------
		Ensures compatibility between producers and consumers as event schemas evolve. 
		Techniques such as schema evolution, backward compatibility, and versioned APIs help manage changes in event structure over time.
	
	
	8. Event Mesh: 
	-------------
		An infrastructure layer that enables events to be shared securely, reliably, and at scale across distributed applications, devices, and cloud services. 
		
		** It provides features like event routing, filtering, transformation, and observability.
	
	
	9. Event-Driven Microservices: 
	------------------------------
		Combines microservice architecture with event-driven patterns, emphasizing autonomous services that communicate through events. 
		
		** This approach enhances scalability, resilience, and agility by minimizing direct dependencies and promoting asynchronous communication.

	
How It Works:
-------------
	1. An event occurs (e.g., a user places an order).
	2. The event is published to a message broker.
	3. One or more services subscribe to that event and react accordingly (e.g., inventory service updates stock, notification service sends confirmation).	

	
https://www.geeksforgeeks.org/system-design/event-driven-apis-in-microservice-architectures/
	
How to implement Event-Driven APIs:
-----------------------------------
	Implementing Event-Driven APIs in system design involves several key steps and considerations to ensure effective communication, scalability, and reliability within a distributed architecture. 
	
	Here’s a structured approach to implementing Event-Driven APIs:
	
	Step 1: Identify Events and Event Sources:
	------------------------------------------
		Identify Business Events: 
			Determine the significant state changes or actions in your system that should trigger events. For example, user registration, order placement, or inventory updates.
		
		Identify Event Sources: 
			Identify components or services (event producers) responsible for emitting these events based on specific triggers or actions.
			
			
	Step 2: Define Event Schemas:
	-----------------------------
		Event Payloads: 
			Define clear and structured event schemas that specify the data format and content of each event. This ensures consistency and interoperability between producers and consumers.
		
		Event Metadata: 
			Include metadata such as event ID, timestamp, and source information to facilitate event processing and auditing.

	Step 3: Choose an Event Broker or Message Bus:
	----------------------------------------------
		Select a suitable message broker or event bus (e.g., Apache Kafka, RabbitMQ, AWS SNS/SQS) to manage event distribution and delivery.
		Configure topics or channels within the broker to categorize and route events based on their type or source.			
	
	Step 4: Implement Event Producers:
	----------------------------------
		Develop components or services responsible for producing events based on predefined triggers or actions.
		Integrate event publishing logic within your application components to emit events to the chosen message broker.
	
	Step 5: Implement Event Consumers:
	----------------------------------
		Develop components or services that subscribe to relevant events from the message broker.
		Implement event handling logic to react to received events, such as updating databases, triggering workflows, or sending notifications.
	
	Step 6: Ensure Reliability and Consistency:
	-------------------------------------------
		Implement mechanisms for handling event delivery failures, such as retry policies and dead-letter queues.
		Ensure idempotency in event processing to handle duplicate event deliveries without unintended side effects.
	
	Step 7: Monitor and Manage Event Flows:
	---------------------------------------
		Implement monitoring and observability tools to track event throughput, latency, and system health.
		Use logging and metrics to diagnose issues, optimize performance, and ensure robust event processing.
	
	Step 8: Handle Event Versioning and Evolution:
	----------------------------------------------
		Establish practices and tools for managing event schema evolution and versioning.
		Ensure backward compatibility when modifying event schemas to prevent disruptions in event-driven communication.
	
	Step 9: Secure Event Communication:
	-----------------------------------
		Implement security measures such as authentication, authorization, and encryption to secure event communication between producers and consumers.
		Consider access control mechanisms to restrict access to sensitive events and data.
	
	Step 10: Scale and Optimize Event-Driven Architecture:
	------------------------------------------------------
		Design for scalability by distributing event processing across multiple instances or services.
		Optimize event-driven workflows and interactions to minimize latency and maximize throughput.
	
	Step 11: Testing and Validation:
	--------------------------------
		Conduct thorough testing of event-driven interactions, including unit testing, integration testing, and end-to-end testing of event flows.
		Validate event handling and reliability under various scenarios, including high event volumes and failure conditions.


Impact on Performance and Scalability:
--------------------------------------
	The performance and scalability of Event-Driven APIs in microservice architectures are critical factors that determine the system's ability to handle varying workloads, maintain responsiveness, and accommodate growth. Here’s how these aspects are addressed and optimized:

		1. Asynchronous Communication
		2. Scalability Through Partitioning
		3. Load Balancing
		4. Handling Backpressure
		5. Optimized Event Processing
		6. Horizontal Scaling of Microservices

	1. Asynchronous Communication:
	------------------------------
		Event-Driven APIs facilitate asynchronous communication between microservices. This decouples producers and consumers, allowing them to operate independently and handle varying workloads without blocking each other. Asynchronous processing improves overall system responsiveness by reducing wait times and bottlenecks.
	
	2. Scalability Through Partitioning:
	------------------------------------
		Event brokers like Apache Kafka or RabbitMQ support partitioning of topics. This allows events to be distributed across multiple partitions and processed concurrently by consumers. Partitioning enhances scalability by enabling horizontal scaling of event processing, where additional consumer instances can be added to handle increased event volumes.
	
	3. Load Balancing: 
	------------------
		Event-driven architectures can leverage load balancing strategies to evenly distribute event processing tasks across multiple consumer instances. This ensures optimal resource utilization and prevents overload on individual services, thereby improving overall system performance.
	
	4. Handling Backpressure:
	-------------------------
		In scenarios where consumers are unable to keep up with the rate of incoming events, event-driven architectures employ mechanisms such as flow control and backpressure handling. These mechanisms allow consumers to signal producers to slow down event production temporarily, preventing overload and maintaining system stability.
	
	5. Optimized Event Processing:
	------------------------------
		Implementing efficient event processing logic within consumers is crucial for performance optimization. This includes minimizing processing time, reducing unnecessary computations, and leveraging parallelism or concurrency where feasible. Optimized event processing ensures that systems can handle high event throughput without compromising latency.
	
	6. Horizontal Scaling of Microservices:
	---------------------------------------
		Beyond event processing, the scalability of microservices themselves plays a crucial role. Microservices should be designed for horizontal scaling, allowing additional instances to be deployed as needed to handle increased event-driven workload.
	
	
Strategies for Error Handling in EDA:
-------------------------------------
	Effective error handling in Event-Driven Architecture (EDA) is crucial for ensuring system reliability, scalability, and data integrity. Here are some key strategies for managing errors in an EDA system:
	
	These techniques help prevent issues from spreading, manage errors gracefully, and keep your system running efficiently, even when unexpected problems arise.
	
		1. Retry Mechanism
		2. Dead-Letter Queues (DLQ)
		3. Idempotency
		4. Circuit Breakers
		5. Event Logging and Monitoring	
	
	
Importance of Error Handling in Event-Driven Architecture:
----------------------------------------------------------
	Error handling in Event-Driven Architecture (EDA) is crucial for maintaining the reliability, stability, and performance of a system.
	you can ensure your system can recover from failures and maintain smooth operations.
		
	1. System Resilience
	2. Data Integrity
	3. Operational Visibility
	4. Scalability and Performance
	5. User Experience
	
	
Architecture Styles:
--------------------
	Simple Event Processing: 		Events are processed in real-time, one at a time.
	Complex Event Processing (CEP): Detects patterns among multiple events (e.g., fraud detection).
	Event Streaming: 				Continuous flow of events (e.g., using Apache Kafka).	
	
	
Benefits:
---------
	Loose Coupling: 	Services are independent and communicate via events.
	Scalability: 		Easy to scale individual components.
	Flexibility: 		New consumers can be added without changing producers.
	Resilience: 		Failures in one component don’t necessarily affect others.	
	
	Auditability: 		Full history of changes.
	Debugging: 			Easy to trace how a state was reached.
	Temporal Queries: 	You can query the state at any point in time.
	Scalability: 		Works well with distributed systems and CQRS (Command Query Responsibility Segregation).
	
	facilitate independent development and deployment.
	improved scaling and fault tolerance.
	integration with external systems.
	
	
Challenges:
-----------
	Debugging and Monitoring: 	Harder to trace event flow.
	Event Ordering: 			Ensuring correct sequence of events.
	Data Consistency: 			Especially in distributed systems.	
	
	Event Versioning: 			Handling changes in event structure over time.
	Complexity: 				More moving parts than traditional CRUD.
	Storage Growth: 			Event logs can grow large.
	
	
Common Use Cases:
-----------------
	E-commerce order processing
	Real-time analytics
	IoT systems
	Microservices communication
	Fraud detection	
	
	
Event Sourcing vs Event-Driven Architecture:
--------------------------------------------
	Feature					Event Sourcing						Event-Driven Architecture
	-------					--------------						-------------------------
	Focus					Storing state changes as events		Reacting to events
	Event Storage			Central to the pattern				Optional
	State Reconstruction	From event history					Not typically reconstructed
	Use Case				Audit logs, financial systems		Microservices, real-time systems	
	

Event-Driven Architecture (EDA):
--------------------------------
	An event-driven architecture consists of event producers that generate a stream of events, event consumers that listen for these events, and event channels that transfer events from producers to consumers.
	
	Producers are decoupled from consumers: A producer doesn't know which consumers are listening. 
	Consumers are also decoupled from each other, and every consumer sees all of the events.
	
	EDA patterns support: 
		real-time event processing, 
		event sourcing, 
		command query responsibility segregation (CQRS), and 
		pub/sub messaging.
	
	When combined, these patterns and technologies enable a scalable and resilient architecture for handling a large volume of events.
	
	
																			(Event Consumers)
																			--------------------------------------						
																			(↙ OrderPlacedEvent) Inventory Service

			Event Producer	(← OrderPlacedEvent ←)		Event Broker		(← OrderPlacedEvent)  Shipping Service
		    (Order Service)							  (Kafka / RabbitMQ)
																			(↖ OrderPlacedEvent)  Notification Service
			
			

		 Diagram Highlights:
		 -------------------
			Event Producer: 	Emits events (e.g., Order Service).
			Event Broker: 		Routes events to consumers (e.g., Kafka, RabbitMQ).
			Event Consumers: 	React to events (e.g., Inventory, Shipping, Notification services).

			1. Order Service acts as the Event Producer.
			2. It sends an OrderPlacedEvent to the Kafka Topic (order-events).
			3. Multiple Event Consumers (Inventory, Shipping, Notification Services) subscribe to the topic and react to the event.

	An ideal framework for implementing this pattern is Apache Kafka.
	
	Kafka is an open-source streaming data pipeline framework for collecting, storing, and processing events, and the data about them, in real-time.
	Flink is an open-source stream processing framework that brings more power and capability to the EDA pattern.
	
	Together, Kafka and Flink enable a wide range of capabilities to capture events and data from multiple sources, which can then be processed, filtered, and further augmented via powerful and scalable data pipeline and stream processing, to be made available to additional downstream consumers and microservices.
	

Eventual Consistency:
---------------------
	Event-driven systems leverage eventual consistency, employing techniques like:
		Event Sourcing and 
		CQRS.
		
	Event sourcing:  
		captures all changes to the system state as a sequence of events, facilitating system reconstruction at any point.
		
	CQRS:			 
		Separates read and write operations, enabling efficient querying while maintaining consistency.	
	
	
	
Real-World Examples:
-------------------

	1. E-commerce Order Processing:
	-------------------------------
		When a customer places an order, an event is triggered to initiate inventory management, payment processing, and shipping coordination.

	2. Internet of Things (IoT) Data Collection:
	--------------------------------------------
		IoT devices generate events when sensor data surpasses a certain threshold, enabling real-time monitoring and analysis for various applications.

	3. User Registration & Authentication:
	--------------------------------------
		When a user signs up or logs in, events are triggered to verify credentials, update user profiles, and grant access to different system resources.

	4. Notification System:
	-----------------------
		Events are triggered when specific conditions are met, such as new messages received or tasks assigned, notifying relevant users via email, SMS, or push notifications.

	5. Stock Market Trading:
	------------------------
		When market conditions change, events are generated to trigger automated trading strategies, enabling real-time execution of buy/sell orders.

	6. Real-Time Analytics:
	-----------------------
		Events are triggered when data streams are received, allowing continuous analysis and insights generation, such as monitoring website traffic or detecting fraudulent activities.

	7. Workflow Management:
	-----------------------
		When a task is completed or a milestone is reached, events are triggered to move the workflow forward, ensuring seamless collaboration and process automation.

	8. Sensor Integration in Smart Homes:
	-------------------------------------
		Events are generated when sensors detect motion, temperature changes, or door openings, triggering actions like turning on lights or adjusting thermostat settings.

	9. Event-Driven Microservices:
	------------------------------
		Events are used to communicate between different microservices, enabling loosely coupled and scalable systems.
		
		how to implement queries that retrieve data from multiple services:
			The solution is to use an event‑driven architecture. In this architecture, a microservice publishes an event when something notable happens, such as when it updates a business entity. Other microservices subscribe to those events. When a microservice receives an event it can update its own business entities, which might lead to more events being published.
				
			The microservices exchange events via a Message Broker. 
			Message Broker guarantees that events are delivered at least once.
			
		Provided that each service atomically updates the database and publishes an event.
		you can implement business transactions that span multiple services. It is important to note that these are not ACID transactions. They offer much weaker guarantees such as eventual consistency. 	
		
		Another benefit is that it also enables an application to maintain materialized views. The service that maintains the view subscribes to the relevant events and updates the view.
			
	
	10. Online Gaming:
	------------------
		Events are triggered when players perform actions, such as moving characters or completing quests, allowing real-time interaction and gameplay synchronization among participants.	


Conclusion:
-----------
	In conclusion, Event-Driven APIs play a crucial role in enhancing the flexibility, scalability, and responsiveness of microservice architectures. 
	By facilitating asynchronous communication through events, these APIs enable services to operate independently, reacting promptly to changes without direct dependencies. 
	This approach promotes system resilience, as failures in one service don’t disrupt the entire system. 
	Event-Driven APIs also support real-time data processing, efficient resource utilization, and seamless integration of diverse services. 
	Embracing these APIs empowers developers to build robust, agile systems capable of meeting evolving business demands and delivering superior user experiences in today's dynamic technological landscape.



========================Event Sourcing=====================================================================================

The Event Sourcing Pattern is a way to store data by recording every change as a sequence of events, instead of just saving the latest state. These events form a complete history of what happened to your data over time.
By replaying these events, the system can rebuild the current state or investigate past states, making Event Sourcing ideal for handling complex workflows.

Here are some real-world examples of companies and systems that use "event sourcing" to manage complex state and ensure traceability:
-------------

	E-commerce Platforms:
	---------------------
		Use Case: Order lifecycle (OrderPlaced, PaymentReceived, OrderShipped, OrderCancelled).
		Why: 	Allows tracking every step of an order, supports customer service queries, and enables replaying events for analytics.
		Example: Amazon-like systems often use event sourcing in combination with event-driven architecture.	
		
		
	Use Cases and Applications of Event Sourcing:
	---------------------------------------------
		Event Sourcing finds applications in diverse domains and use cases where tracking and analyzing historical data is crucial. Below are some notable examples:
		
		1. Financial Systems: 
		---------------------
			To keep an unchangeable record of transactions, account activity, and compliance events, banking and financial institutions use event sourcing.
		
		2. Healthcare Records: 
		----------------------
			Electronic health record (EHR) systems use event sourcing to document patient contacts, treatment histories, and medical procedures.
		
		3. Supply Chain Management: 
		---------------------------
			Event sourcing is used in supply chain and logistics management to track inventory movements, shipping updates, and supply chain interruptions.
		
		4. E-commerce Platforms: 
		-----------------------
			Event sourcing is a useful tool for e-commerce applications to record customer interactions, order fulfillment processes, and inventory changes. This makes it feasible to track orders, offer customized recommendations, and examine customer behavior in order to boost sales and customer satisfaction.
		
		5. Gaming and Virtual Environments: 
		-----------------------------------
			Event Sourcing is used in virtual worlds and multiplayer online games to record player movements, game state changes, and in-game purchases.
	
When to Use Event Sourcing Pattern:
-----------------------------------
	Use Event Sourcing Pattern when:

	1. It's good for apps with complicated rules that need to keep track of how things change over time.
	2. It helps when you need a complete history of changes for legal reasons or audits.
	3. Useful for systems that need to save old data, like financial information.
	4. Helps your app bounce back quickly from problems by replaying past events.
	5. Works well in systems with separate parts (like microservices) that need to communicate without being tightly linked.
	
	
When not to Use Event Sourcing Pattern:
---------------------------------------
	Event Sourcing may not be the best choice in these situations:

	1. Simple Applications: 
	-----------------------
		If an application just needs to track the most recent state and doesn't require a thorough history or audit trail, Event Sourcing may introduce needless complexity.
	
	2. High Storage Costs: 
	----------------------
		Event Sourcing stores every change as an event, which can lead to high storage costs, especially if there are frequent updates or changes.
	
	3. Complex Data Consistency Needs: 
	----------------------------------
		Managing consistency across multiple events can become challenging, especially when coordinating data between different services or systems.
	
	4. Performance Sensitivity: 
	---------------------------
		Replaying events to rebuild the state can slow down performance in applications where quick data retrieval is essential.	
		
Conclusion:
-----------
	By recording every change as a separate event, it provides an accurate and immutable record of all actions taken within a system.
	This pattern offers benefits such as improved auditability, scalability, and resilience. It enables accurate historical analysis, real-time tracking of system state, and efficient troubleshooting.
	
		
Implementing event sourcing in an e-commerce system:
----------------------------------------------------		
	Implementing event sourcing in an e-commerce system involves modeling every significant change in the system as an event and storing those events in an append-only log.		
	
	
	Scenario: Order Management in E-commerce:
	-----------------------------------------
		1. Define Domain Events:
		------------------------
			Choosing clear, descriptive, and domain-specific event names is crucial in event sourcing. 
			
			Each event represents a state change in the order lifecycle:
				OrderPlaced
				ItemAddedToOrder
				ItemRemovedFromOrder
				OrderConfirmed
				PaymentReceived
				OrderShipped
				OrderCancelled
				ProductOutOfStock

			Each event typically includes:
				A unique ID
				Timestamp
				Event type
				Payload (e.g., item ID, quantity, user ID)
				
				
			Tips for Naming Events:
				Use past tense: 			Events represent something that has already happened.
				Be specific: 				Avoid vague names like DataUpdated.
				Reflect business language: 	Use terms your domain experts would understand.	


		2. Event Store:
		---------------
			Use a database or specialized event store (like EventStoreDB, Kafka, or a relational DB with an events table) to persist events.
	
			{
			  "event_id": "uuid",
			  "event_type": "OrderPlaced",
			  "aggregate_id": "order-123",
			  "timestamp": "2025-06-25T12:00:00Z",
			  "payload": {
				"user_id": "user-456",
				"items": [{"product_id": "p1", "qty": 2}]
			  }
			}
	
	
		3. Aggregate Root:
		------------------
			The Order aggregate is rebuilt by replaying its events:
				
				class Order:
					def __init__(self, events):
						self.items = []
						self.status = "NEW"
						for event in events:
							self.apply(event)

					def apply(self, event):
						if event.type == "ItemAddedToOrder":
							self.items.append(event.payload["item"])
						elif event.type == "OrderConfirmed":
							self.status = "CONFIRMED"
						# ... handle other events


		4. Command Handling:
		--------------------
			Commands trigger events:
			
				def handle_add_item(order, item):
					if order.status != "CONFIRMED":
						return Event("ItemAddedToOrder", {"item": item})
					else:
						raise Exception("Cannot add items to a confirmed order")


		5. Publishing Events:
		---------------------
			After storing, events can be published to a message broker (e.g., Kafka) for other services to react (e.g., inventory, shipping, notifications).
			
			
		6. Rebuilding State:
		--------------------
			To get the current state of an order, replay all events for that order ID.	
			
			
		7. Projections (Read Models):
		-----------------------------
			For fast querying, build projections (e.g., current order status, user order history) by subscribing to events and updating a read-optimized database.	
			
			
How Event Sourcing Pattern works?
---------------------------------
	Below are the steps to understand how event sourcing pattern works:

	1. Capture Events Instead of State: 
	-----------------------------------
		Every system modification is documented as an event (e.g., “order created,” “item added,” “order completed”) rather than just preserving the final state (e.g., “order is completed”). Every event denotes a distinct action or modification.
	
	2. Store Events in Sequence: 
	----------------------------
		All events are stored in a sequence (often in a database or event store) in the exact order they occurred. This sequence of events acts as the "source of truth" for the system.
	
	3. Reconstruct State by Replaying Events: 
	-----------------------------------------
		When you need to know the current state, the system “replays” or processes all past events to build up the state from scratch.
	
	4. Handle New Events: 
	--------------------
		As new changes happen, new events are created and added to the sequence. For instance, if an order is updated, a new event (e.g., “order updated”) is added to the sequence without changing or removing past events.
	
	5. Replay Events for Debugging: 
	-------------------------------
		If you need to see the history or investigate an issue, you can replay events to see how the state evolved over time. This replay ability makes it easy to understand the sequence of actions taken and trace any errors or issues.			
			
			
Challenges in event-sourcing implementation and their solutions:
----------------------------------------------------------------			

	1. Event Versioning:
	--------------------
		Problem: 	Over time, your event structure may change (e.g., adding fields).
		
		Solution: 	
		---------
			Use versioned schemas or serialization formats like Avro/Protobuf. Maintain backward compatibility.
			Add version numbers to events.
			Use upcasters to transform old events into the current format during replay.
			
		Mistake: Assuming events will always arrive in the correct order.
		Instead: Use sequence numbers or timestamps to detect and handle out-of-order events.	
		
			
	2. Complex State Reconstruction:
	--------------------------------
		Problem: 	Rebuilding aggregates from a long event history can be slow.
		
		Solution: 	
		---------
			Use snapshots to periodically save the current state and reduce replay time.
			Use caching for frequently accessed aggregates.
			
	3. Testing and Debugging:
	-------------------------
		Problem: 	Harder to test and debug because state is derived from a sequence of events.
		
		Solution: 	
		---------
			Build tools to visualize event streams.
			Use event replayers to simulate scenarios.
			Write unit tests for aggregates using event histories.
			
	4. Eventual Consistency:
	------------------------
		Problem: 	Read models and projections may lag behind the write model.
		
		Solution: 	
		---------
			Design with idempotent event handlers.	(Ensure handlers can safely process the same event multiple times.)
			Use retry queues and dead-letter queues for failed events.
			Communicate consistency expectations clearly in APIs.	
		
	5. Event Store Management:
	--------------------------
		Problem: 	Event logs grow indefinitely.
		
		Solution: 	
		---------
			Archive old events.
			Store events in partitioned tables or cold storage for long-term retention.
			Implement retention policies.	
		
	6. Handling Failures and Retries:
	---------------------------------
		Problem: 	If an event handler fails, it may leave the system in an inconsistent state.
		
		Solution: 	
		---------
			Implement retry mechanisms, 
			dead-letter queues,
			idempotent handlers,
			Monitor and alert on failed event handlers.
		
		
	7. Security and Compliance:
	---------------------------
		Problem: 	Events may contain sensitive data that must be protected or deleted (e.g., GDPR).
		
		Solution: 	
		---------
			Encrypt sensitive fields, 
			design for data redaction or event tombstoning.	
			Avoid storing PII directly in events when possible.

			
	8. Tooling and Infrastructure:
	------------------------------
		Problem: 	Requires specialized tools for event storage, processing, and monitoring.
		
		Solution: 	
		---------
			Use mature platforms like EventStoreDB, Kafka, or Axon Framework.	
			Invest in observability: logging, tracing, and metrics for event flows.


Best frameworks for implementing event sourcing in Java:
--------------------------------------------------------
	1. Axon Framework
	2. Eventuate
	3. Lagom Framework (by Lightbend)
	4. JEventStore
	5. Spring Boot + Custom Implementation		(Integrates well with Kafka, PostgreSQL, MongoDB, etc.)	
	
	
	
================================================================================		
https://www.f5.com/company/blog/nginx/event-driven-data-management-microservices	
	
->Challenges in maintain consistency across multiple services:
--------------------------------------------------------------
	The first challenge is how to implement business transactions that maintain consistency across multiple services. 
	The second challenge is how to implement queries that retrieve data from multiple services.

To see why this is a problem, let’s take a look at an example of an online B2B store. 
	The Customer Service maintains information about customers, including their credit lines. 
	The Order Service manages orders and must verify that a new order doesn’t exceed the customer’s credit limit. 
	
	In the monolithic version of this application, 
		the Order Service can simply use an ACID transaction to check the available credit and create the order.		

	In contrast, in a microservices architecture, 
		the ORDER and CUSTOMER tables are private to their respective services.
		The Order Service cannot access the CUSTOMER table directly. 
		It can only use the API provided by the Customer Service. 	
		
		The Order Service could potentially use distributed transactions, also known as two‑phase commit (2PC). 
		However, 2PC is usually not a viable option in modern applications. 
		
		The CAP theorem requires you to choose between availability and ACID‑style consistency, and availability is usually the better choice. 
		
		Moreover, many modern technologies, such as most NoSQL databases, do not support 2PC. 	
		
	Maintaining data consistency across services and databases is essential, so we need another solution.
	
	The solution is to use an event‑driven architecture.	 
		
	You can use events to implement business transactions that span multiple services.	
	The microservices exchange events via a Message Broker.
	Provided that each service atomically updates the database and publishes an event.
	you can implement business transactions that span multiple services. It is important to note that these are not ACID transactions. They offer much weaker guarantees such as eventual consistency. 	
	
	An event‑driven architecture has several benefits and drawbacks:	
		One benefit is, it enables the implementation of transactions that span multiple services and provide eventual consistency. 
		One drawback is, The application can see inconsistencies if it reads from a materialized view that is not yet updated. Another drawback is that subscribers must detect and ignore duplicate events.
		
		
Achieving Atomicity:
--------------------
	In an event‑driven architecture there is also the problem of atomically updating the database and publishing an event. 
	
	For example, 
		the Order Service must insert a row into the ORDER table and publish an Order Created event. 
		It is essential that these two operations are done atomically. 
		If the service crashes after updating the database but before publishing the event, the system becomes inconsistent. 
		The standard way to ensure atomicity is, to use a distributed transaction, involving the database and the Message Broker. 
		However, for the reasons described above, such as the CAP theorem, this is exactly what we do not want to do.

Below are the ways to achieve automicity:
-----------------------------------------
	
	1. Publishing Events Using Local Transactions:
	---------------------------------------------
	One way to achieve atomicity is for the application to publish events using a multi‑step process involving only local transactions. 
		A limitation of this approach is that it is challenging to implement when using some NoSQL databases because of their limited transaction and query capabilities.
		Although, This approach eliminates the need for 2PC by having the application use local transactions to update state and publish events. 

	2.Using Event Sourcing:
	-----------------------
		The application stores a sequence of state‑changing events. Whenever the state of a business entity changes, a new event is appended to the list of events. Since saving an event is a single operation, it is inherently atomic.
		
		Event sourcing has several benefits. 
			It solves one of the key problems in implementing an event‑driven architecture and makes it possible to reliably publish events whenever state changes. As a result, it solves data consistency issues in a microservices architecture. 
			
		Event sourcing also has some drawbacks.
			The event store only directly supports the lookup of business entities by primary key. 
			You must use Command Query Responsibility Segregation (CQRS) to implement queries. 
			As a result, applications must handle eventually consistent data.
			
		To see how event sourcing works:
		--------------------------------
			consider the Order entity as an example.
			
			The Order Service stores an Order in the form of its state‑changing events: Created, Approved, Shipped, Cancelled. 
			Each event contains sufficient data to reconstruct the Order’s state.
				
			Events persist in an Event Store, which is a database of events. 

			The store has an API for adding and retrieving an entity’s events.

			The Event Store also behaves like the Message Broker in the architectures we described previously. It provides an API that enables services to subscribe to events.
				
			The Event Store delivers all events to all interested subscribers. 
			
			The Event Store is the backbone of an event‑driven microservices architecture.
	
Summary:
--------
	In a microservices architecture, each microservice has its own private datastore. Different microservices might use different SQL and NoSQL databases. While this database architecture has significant benefits, it creates some distributed data management challenges. 

	The first challenge is how to implement business transactions that maintain consistency across multiple services. 
	The second challenge is how to implement queries that retrieve data from multiple services.	
	
	For many applications, the solution is to use an event‑driven architecture.
	
	One challenge with implementing an event‑driven architecture is how to atomically update state and how to publish events. 
	
	There are a few ways to accomplish this, including using the database as a message queue, transaction log mining, and event sourcing.
	
	


Request-driven vs Event-driven Microservices:
---------------------------------------------
	Understanding the various communication patterns is crucial. Two predominant models are request-driven and event-driven microservices.
	
	Request-driven Microservices	(Synchronous Communication)
	Event-driven Microservices		(Asynchronous Communication)

	Feature						Request-driven Microservices			Event-driven Microservices
	-------						----------------------------			--------------------------
	Communication Model			Synchronous (request-response)			Asynchronous (event-based)
	Coupling					Tight coupling between services			Loose coupling
	Response Time				Direct waiting for responses			Non-blocking; responses occur independently
	Scalability					Can lead to bottlenecks					High scalability, suitable for many events
	Complexity					Generally simpler to implement			More complex due to event management
	Debugging					Easier to trace request flows			Harder to debug; requires tracking events
	Use Cases					APIs, payment processing				Order management, notifications
	Data Consistency			Easier to ensure consistency			Requires strategies for eventual consistency	


Use Cases of Request-driven Microservices:
------------------------------------------
	Below are the use cases of request-driven microservices:

	User Authentication: 
	--------------------
		Request-driven microservices excel in handling user login and authentication processes that require immediate feedback.
	
	Payment Processing: 
	-------------------
		Applications like e-commerce platforms benefit from synchronous requests for processing transactions to ensure accuracy and speed.
	
	APIs for Web Applications: 
	--------------------------
		Real-time data retrieval for web applications often relies on request-driven microservices for fetching and displaying dynamic content.
	
	CRUD Operations: 
	---------------
		Basic Create, Read, Update, and Delete operations often utilize request-driven models for straightforward data management.


Use Cases of Event-driven Microservices:
----------------------------------------
	Below are the use cases of event-driven microservices:

	Order Processing: 
	-----------------
		E-commerce platforms can utilize event-driven microservices to decouple order placement from inventory updates, allowing for more flexible and resilient processing.
	
	Notification Systems: 
	---------------------
		Applications that require real-time notifications (e.g., messaging apps) can benefit from the asynchronous nature of event-driven microservices.
	
	Real-time Analytics: 
	--------------------
		Systems that analyze data in real-time, such as monitoring applications, can effectively use event-driven architectures to react to data streams instantly.
	
	Microservices Communication: 
	----------------------------
		Services can communicate via events to trigger workflows or processes without direct dependencies, enhancing modularity and flexibility.



Message-Driven Architecture vs. Event-Driven Architecture:
----------------------------------------------------------
	Message-driven and event-driven architectures are both communication patterns used to build scalable, decoupled systems. They focus on how components communicate asynchronously. 
		
	
	Features				Message-Driven Architecture				Event-Driven Architecture
	--------				---------------------------				-------------------------
	Communication Focus		Message delivery between services		Reaction to events or changes
	Coupling				Tight coupling (sender to receiver)		Loose coupling between components
	Real-time Capability	Delayed, not always real-time			Real-time reactions to events
	Complexity				Easier to track and manage messages		More complex due to event sourcing
	Scalability				Scalable for high message volume		Scalable and flexible for dynamic systems
	Delivery Guarantee		Strong message delivery guarantees		Harder to guarantee event delivery	
	Examples				Message queues, publish-subscribe 		Order placement, sensor data updates triggering actions
	
							systems, request-reply patterns.
	
	Use Cases of Message-Driven Architecture (MDA):
	-----------------------------------------------
	Below are the use cases of Message-Driven Architecture (MDA):

		1. Asynchronous Communication: 
		------------------------------
			MDA is ideal for systems where components need to communicate without waiting for responses, such as in order processing systems or payment gateways.
		
		2. Decoupled Systems: 
		---------------------
			In applications that require loose coupling between services (e.g., microservices), MDA allows independent development and deployment, improving maintainability.
		
		3. Load Balancing: 
		------------------
			Distributing incoming messages among multiple consumers helps manage load effectively, as seen in e-commerce platforms during peak times.
		
		4. Retry Mechanisms: 
		--------------------
			MDA can handle transient failures by retrying message processing, making it suitable for systems that require high reliability, like financial transaction systems.
		
		5. Integration of Legacy Systems: 
		---------------------------------
			MDA can facilitate integration between modern applications and legacy systems by enabling communication through message queues.
		
		6. Real-time Notifications: 
		---------------------------
			Systems that require real-time updates (like chat applications or collaboration tools) benefit from MDA for delivering messages instantly.
			
			
	Use Cases of Event-Driven Architecture (EDA):
	---------------------------------------------
	Below are the use cases of Event-Driven Architecture (EDA):

		1. Reactive Systems: 
		--------------------
			EDA supports reactive programming models, making it suitable for applications that need to respond to user actions or system events in real-time (e.g., online gaming).
		
		2. Scalability: 
		---------------
			Ideal for systems that require dynamic scaling based on events, such as IoT applications where devices send data triggers based on environmental changes.
		
		3. Complex Event Processing: 
		----------------------------
			EDA is great for scenarios requiring real-time analysis of events, such as fraud detection in financial transactions.
		
		4. Microservices Coordination: 
		------------------------------
			EDA facilitates coordination among microservices through event streams, allowing services to react to changes in a distributed manner.
		
		5. Data Pipelines: 
		------------------
			Used in data processing frameworks where events represent data changes, enabling real-time analytics (e.g., streaming data from sensors).
		
		6. Workflow Automation: 
		-----------------------
			EDA can automate business processes by triggering workflows based on events, such as triggering an approval process in a document management system.		
			
			
			
Event Sourcing vs. Event Streaming in System Design:
----------------------------------------------------
	Event Sourcing and Event Streaming are two fundamental concepts in modern system design that address how data is captured, stored, and processed. 
	
	Event Sourcing involves persisting the state of an application as a series of immutable events, allowing for the reconstruction of the current state through event replay. In contrast, 
	
	Event Streaming focuses on the real-time flow of events between systems, enabling immediate data processing and responsiveness.
	
		
	Feature				Event Sourcing									Event Streaming
	-------				--------------									---------------
	Main Purpose		Stores every event to recreate state later		Handles and processes events in real-time
	Data Handling		Rebuilds current state from past events			Processes data as it happens
	Use Cases			Audit logs, rebuilding states					Real-time data pipelines, live feeds
	Storage				Stores all past events							Often keeps only a short history or none
	Complexity			More complex to manage long-term				Can be complex to set up and maintain
	Processing Speed	Slower due to replaying events					Faster as it processes events live
	Error Handling		Easier to fix issues by replaying events		More difficult if an event is lost in real-time	
	
	Conclusion:
	-----------
		Event Sourcing and Event Streaming both handle events but serve different purposes. 
		Event Sourcing is great for systems where the full history is needed, while Event Streaming is best for real time data handling. 
		Choosing between them depends on whether you need to store all events or process them in real time.
		
		
There are two primary approaches to structure event payloads:
-------------------------------------------------------------
	When you have control over your event consumers, you can decide on the payload structure for each consumer:	
		1. Include all required attributes in the payload
		2. Include only keys in the payload	

	1. Include all required attributes in the payload: 
	--------------------------------------------------
		Use this approach when you want consumers to have all available information without needing to query an external data source. 
		However, it can lead to data consistency problems because of multiple systems of record, particularly after updates. Contract management and versioning can also become complex.

	2. Include only keys in the payload: 
	------------------------------------
		In this approach, consumers retrieve the necessary attributes, such as a primary key, to independently fetch the remaining data from a data source. This method provides better data consistency because it has a single system of record. 
		However, it can perform poorer than the first approach because consumers must query the data source frequently. 


There are two primary topologies within many event-driven architectures:
------------------------------------------------------------------------
	https://learn.microsoft.com/en-us/azure/architecture/guide/architecture-styles/event-driven	
		
	
	
diff b/w message queue or event driven architecture:
----------------------------------------------------
	In a message queue system, components communicate through point-to-point messages, where the sender knows the receiver. 
	In contrast, event-driven architecture uses a publish-subscribe model where events are broadcast, and components (subscribers) react to relevant events without needing to know the sender.	
	
	While message queues focus on reliable, asynchronous communication and task processing, 
	event-driven architectures are geared towards real-time responsiveness and flexible event handling. 
	
	Message Queue:
		Point-to-point: Messages are directed to a specific recipient. 
		Asynchronous: Senders don't need to wait for immediate responses. 
		Reliable: Message queues ensure messages are delivered and processed. 
		Suitable for: Tasks requiring sequential processing, job queues, and systems where reliability is paramount. 
	
	Event-Driven Architecture:
		Publish/Subscribe: Events are broadcast to a wider audience, not a specific recipient. 
		Decoupled: Components don't need to know about each other's existence. 
		Real-time: Events are processed as they happen, enabling quick responses. 
		Suitable for: IoT applications, real-time analytics, and systems needing high responsiveness. 